#!/bin/bash
#
# Copyright Â© 2021 b Jean-Jacques Brucker <jjbrucker@free.fr>
#          Confidential - All Right Reserved
#
# Bash library and executable that wraps 'logger to write log on stderr or syslog,
# then exit if log level is more serious than PL_LOGEXITLNAME.
#
# TODO: complete completion

if [[ "$1" == --bash-completion ]] ; then
	_pl_log_completion()
	{
		local cur prev options
		local IFS=$'\n'

		COMPREPLY=()
		cur=${COMP_WORDS[COMP_CWORD]}

		if [[ "$cur" == -* ]]; then
			options="--syslog --help --version"

			COMPREPLY=( $(IFS=" " compgen -W "$options" -- $cur ) )
		else
			prev=${COMP_WORDS[COMP_CWORD-1]}
			case $prev in
				-o|--output-path)
					COMPREPLY=( $(compgen  -d -- $cur ) )
					return ;;
				# some options will exit without executing any actions, so don't complete anything
				-h|--help|-V|--version)
					return ;;
			esac

		fi
	}
	complete -o filenames -F _pl_log_completion "$BASH_SOURCE"
	return 0
fi

# If sourcing while _pl_log_parseoptions is already set, execute the function and return without reloading rest of file.
if [[ "$BASH_SOURCE" != "$0" ]] && [[ "$(type -t _pl_log_parseoptions)" == function ]] ; then
	_pl_log_parseoptions "$PL_LOG_NAME" "$@"
	return $?
fi

### Constants ###

declare -r PL_LOG_NAME="$(basename $(readlink -f "$BASH_SOURCE") )"
declare -r PL_LOG_VERSION="0.0.1"

declare -Ar PL_LOGLEVELS=(
[emerg]=0
[alert]=1
[crit]=2
[error]=3 # deprecated synonym for err
[err]=3
[warning]=4
[notice]=5
[info]=6
[debug]=7)

### Default option values ###

PL_LOGCOLORS=(47 45 41 31 35 33 36 37)
PL_LOGLEVEL="${PL_LOGLEVEL:-7}"
PL_LOG_O_STDERR="--stderr"
PL_LOG_O_NOACT=""
PL_LOGGER_OPTIONS=""
PL_LOG_COLOR="auto"

if [[ "$BASH_SOURCE" == "$0" ]] ; then
	# run as a program
	set -e
	PL_LOGEXITLNAME="${PL_LOGEXITLNAME:-err}"

	PL_LOG_usage="Usage: $BASH_SOURCE [OPTIONS]... PRIORITY [MESSAGE]..."
	PL_LOG_shelpmsg="
$PL_LOG_NAME is also bash library, see:
$ source $BASH_SOURCE --help"
else
	# run as a library (source $0)
	PL_LOGEXITLNAME="${PL_LOGEXITLNAME:-emerg}"

	PL_LOG_usage="Usage: source $BASH_SOURCE [OPTIONS]..."

	PL_LOG_shelpmsg="
      --bash-completion    set completion for $BASH_SOURCE program and return (without loading anything else)

Reminder: when used as a library, all functions calls share the same environment variables, i.e. the same options."
fi


### Help messages ###

PL_LOG_chelpmsg="
PRIORITY list: $(declare -p PL_LOGLEVELS)
If PRIORITY's level is under PL_LOGLEVEL=$PL_LOGLEVEL, don't log anything.
If PRIORITY's level name is more serious than PL_LOGEXITLNAME=$PL_LOGEXITLNAME, exit(8+'PRIORITY's level')
If there is no MESSAGE in command line, read it from stdin.

Options:
  -l, --log-level LEVEL    log level: emerg<1=alert<crit<3=err<warning<5=notice<info<7=debug (current: $PL_LOGLEVEL)
  -L, --log-exit PRIORITY  log exit priority: emerg|alert|crit|err|warning|... (current: $PL_LOGEXITLNAME )
  -q, --quiet              do not output message to standard error
  -Q, --no-act             do not send message to the logs system (syslog)
      --color[=<on|off|auto>]
                           colorize messages sent to standard error (default: auto)
  -h, --help               show this help and exit (or return)
  -V, --version            show version and exit (or return)

Options forwarded to 'logger':
  -i                       log the logger command's PID
      --id[=<id>]          log the given <id>, or otherwise the PID (default \$\$ = logger's PPID)
  -f, --file <file>        log the contents of this file
  -e, --skip-empty         do not log empty lines when processing files
      --octet-count        use rfc6587 octet counting
      --prio-prefix        look for a prefix on every line read from stdin
  -S, --size <size>        maximum size for a single message
  -t, --tag <tag>          mark every line with this tag (default \${0##*/})
  -n, --server <name>      write to this remote syslog server
  -P, --port <port>        use this port for UDP or TCP connection
  -T, --tcp                use TCP only
  -d, --udp                use UDP only
      --rfc3164            use the obsolete BSD syslog protocol
      --rfc5424[=<snip>]   use the syslog protocol (the default for remote);
                             <snip> can be notime, or notq, and/or nohost
      --sd-id <id>         rfc5424 structured data ID
      --sd-param <data>    rfc5424 structured data name=value
      --msgid <msgid>      set rfc5424 message id field
  -u, --socket <socket>    write to this Unix socket
      --socket-errors[=<on|off|auto>]
                           print connection errors when using Unix sockets
      --journald[=<file>]  write journald entry"


### functions ###

#TODO: explain in comment why we dont use getopts...
_pl_log_parseoptions() {
	local name=$1
	[[ "$name" =~ ^- ]] && { echo -e "Usage: $FUNCNAME NAME \"\$@\"\nFor program/function named NAME: parse Options in \$@ and set ARGV array containing remaining parameters" >&2 ; return 1 ; }
	shift
	for ((;$#;)) ; do
		case "$1" in
			-l|--log-l*) shift ; PL_LOGLEVEL="$1" ; [[ "$PL_LOGLEVEL" == [0-9] ]] || { printf "Error: log-level out of range [0-7]\n" >&2 ; return 2 ; } ;;
			-L|--log-e*) shift ; PL_LOGEXITLNAME="$1"
				grep -q "\<$PL_LOGEXITLNAME\>" <<<${!PL_LOGLEVELS[@]} || { printf "Error: log-exit \"$PL_LOGEXITLNAME\" is none of: ${!PL_LOGLEVELS[@]}\n" >&2 ; return 2 ; } ;;
			-q|--quiet) PL_LOG_O_STDERR="" ;;
			-Q|--no-act) PL_LOG_O_NOACT="--no-act" ;;
			--color|--color=on) PL_LOG_COLOR=on ;;
			--color=off) PL_LOG_COLOR=off ;;
			--color=auto) PL_LOG_COLOR=auto ;;
			-i|-e|--skip-empty|--octet-count|--prio-prefix|-T|--tcp|-d|--udp|--rfc3164)
				PL_LOGGER_OPTIONS+=("$1") ;;
			-f|--file|-S|--size|-t|--tag|-n|--server|-P|--port|--sd-id|--sd-param|--msgid|-u|--socket)
				PL_LOGGER_OPTIONS+=("$1")
				shift
				PL_LOGGER_OPTIONS+=("$1") ;;
			--id*|--rfc5424*|--socket-errors*|--journald*)
				PL_LOGGER_OPTIONS+=("$1") ;;
			-h|--h*) printf "$PL_LOG_usage\n$PL_LOG_chelpmsg\n$PL_LOG_shelpmsg\n" ; return 2 ;;
			-V|--vers*) printf "$name $PL_LOG_VERSION\n" ; return 2 ;;
			--) shift ; break ;;
			-*) printf "$name: unrecognized option '$1'\n$PL_LOG_usage\nTry '$name --help' for more information.\n" >&2 ; return 2 ;;
			*) break ;;
		esac
		shift
	done
	ARGV=("$@")
}


pl_log() {
	local PL_LOG_usage="Usage: $FUNCNAME [OPTIONS]... PRIORITY [MESSAGE]..."
	local -I PL_LOGLEVEL PL_LOGEXITLNAME PL_LOG_O_STDERR PL_LOG_O_NOACT PL_LOGGER_OPTIONS PL_LOG_COLOR
	local PL_LOG_helpmsg="$PL_LOG_chelpmsg"
	_pl_log_parseoptions "$FUNCNAME" "$@" || return $?
	set "${ARGV[@]}"

	local priority=$1 plname=${1##*.} filter
	grep -q "\<$plname\>" <<<${!PL_LOGLEVELS[@]} || { echo -e "Error: log-exit priority's level name ($plname) is none of: ${!PL_LOGLEVELS[@]}" >&2 ; return 2 ; }
	shift
	local llevel=${PL_LOGLEVELS[$plname]}
	if ((llevel > $PL_LOGLEVEL)) ; then
		# If there is no MESSAGE, purge stdin; else do nothing.
		[[ "$@" ]] || cat >/dev/null
	else
		if [[ "$PL_LOG_COLOR" == on ]] || [[ "$PL_LOG_COLOR" == auto ]] && [[ -t 2 ]] ; then
			filter="2> >(sed 's,: ,: \x1b[${PL_LOGCOLORS[$llevel]}m${plname^}:\x1b[0m ,' >&2)"
		else
			filter="2> >(sed 's,: ,: ${plname^}: ,' >&2)"
		fi
		eval 'logger -p "$priority" $PL_LOG_O_STDERR $PL_LOG_O_NOACT --id=$$ --tag "${0##*/}" ${PL_LOGGER_OPTIONS[@]} -- "$@" '"$filter"
	fi
	((llevel > PL_LOGLEVELS[$PL_LOGEXITLNAME] )) || exit $((8+llevel))
}


### Init ###

# Parse Options
_pl_log_parseoptions "$PL_LOG_NAME" "$@"

# Do nothing else if sourced
[[ "$BASH_SOURCE" == "$0" ]] || return 0


### Run ###

pl_log "${ARGV[@]}"
