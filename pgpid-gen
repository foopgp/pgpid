#!/bin/bash
#
# Copyright Â© 2021 by Friends Of OpenPGP organization <info@foopgp.org>.
#          All Right Reserved
#
# Extract MRZ data and photo from ID documents (eg: International Passeports)
# to generate OpenPGP certificates and keys to be imported for multiple applications (mail, chat, vote, etc.).
# May also move or copy 3 importante keys (SC, E and A) to OpenPGP Security hardware (nitrokeys, yubikeys, etc.)
#

if [[ "$1" == --bash-completion ]] ; then
	_pgpi_completion()
	{
		local cur prev options
		local IFS=$'\n'

		COMPREPLY=()
		cur=${COMP_WORDS[COMP_CWORD]}

		if [[ "$cur" == -* ]]; then
			options="--output-path --verbose --quiet --udid --help --version"

			COMPREPLY=( $(IFS=" " compgen -W "$options" -- $cur ) )
		else
			prev=${COMP_WORDS[COMP_CWORD-1]}
			case $prev in
				-o|--output-path)
					COMPREPLY=( $(compgen  -d -- $cur ) )
					return ;;
				# some options will exit without executing any actions, so don't complete anything
				-h|--help|-V|--version)
					return ;;
			esac

			COMPREPLY=( $(compgen -o plusdirs -f -X '!*.@(gif|GIF|jp?(e)g|JP?(E)G|miff|tif?(f)|pn[gm]|PN[GM]|p[bgp]m|bmp|BMP|xpm|ico|xwd|tga|pcx)' -- $cur ) )
		fi
	}
	complete -o filenames -F _pgpi_completion "$BASH_SOURCE"
	return 0
fi

PGPI_NAME="$(basename $(readlink -f "$BASH_SOURCE") )"
PGPI_VERSION="0.0.1"


### Constants ###

FACE_MARGIN_WIDTH="25/100"
FACE_MARGIN_HEIGHT="50/100"
TESSDATADIR="$(dirname "$0")/data/"
GEOLIST_CENTROID="$(dirname "$0")/data/geolist_centroid.txt"
ONLYUDID=false

### Default option values ###

if [[ "$BASH_SOURCE" == "$0" ]] ; then
	# run as a program
	set -e
	# set global constants real constant (read only)
	declare -r FACE_MARGIN_WIDTH FACE_MARGIN_HEIGHT TESSDATADIR GEOLIST_CENTROID
	_exit="exit"
	LOGEXITPRIO=crit
	LOGLEVEL=5

	PGPI_OUTPATH="$PWD"

	usage="Usage: $BASH_SOURCE [OPTIONS]... [--] [IMAGE]
If $PGPI_NAME succeed, it will create a subdirectory containing all generated files.
If no IMAGE is given, $PGPI_NAME will try to use webcam."

	soptions="
    -o, --output-path PATH   emplacement for generated subdirs and files (current: $PGPI_OUTPATH )
    -v, --verbose            increase log verbosity: ...<notice[5]<info[6]<debug[7]  (current: $LOGLEVEL)
    -q, --quiet              decrease log verbosity: ...<err[3]<warning[4]<notice[5]<...  (current: $LOGLEVEL)
    -u, --udid               calculate and output udid string, whithout generating OpenPGP keys
    -h, --help               show this help and exit
    -V, --version            show version and exit"
else
	# run as a library (source $0)
	_exit="true"
	LOGEXITPRIO=emerg
	LOGLEVEL=6

	usage="Usage: source $BASH_SOURCE [OPTIONS]..."

	soptions="
        --bash-completion    set completion for $BASH_SOURCE program and return (without loading anything else)
    -l, --log-level LEVEL    log level: emerg<1=alert<crit<3=err<warning<5=notice<info<7=debug (current: $LOGLEVEL)
    -L, --log-exit PRIORITY  log exit priority: emerg|alert|crit|err|warning|... (current: $LOGEXITPRIO )
    -h, --help               show this help
    -V, --version            show version"
fi

### Handling options ###

helpmsg="$usage

Options: $soptions
"

for ((i=0;$#;)) ; do
case "$1" in
	-o|--output*) shift ; PGPI_OUTPATH="$1" ; ( cd "$PGPI_OUTPATH" && touch . ) ;;
	-l|--log-l*) shift ; LOGLEVEL="$1" ; [[ "$LOGLEVEL" == [0-9] ]] || { echo -e "Error: log-level out of range [0-7]" >&2 ; $_exit 2 ; } ;;
	-L|--log-e*) shift ; LOGEXITPRIO="$1"
		grep -q "\<$LOGEXITPRIO\>" <<<${!loglevels[@]} || { echo -e "Error: log-exit \"$LOGEXITPRIO\" is none of: ${!loglevels[@]}" >&2 ; $_exit 2 ; } ;;
	-v|--verb*) ((LOGLEVEL++)) ;;
	-q|--quiet) ((LOGLEVEL--)) ;;
	-u|--udid) ONLYUDID=true ;;
	-h|--h*) echo "$helpmsg" ; $_exit ;;
	-V|--vers*) echo "$PGPI_NAME $PGPI_VERSION" ; $_exit ;;
	--) shift ; break ;;
	-*) echo -e "Error: Unrecognized option $1\n$helpmsg" >&2 ; $_exit 2 ;;
	*) break ;;
esac
shift
done


### functions ###

. "$(dirname "$BASH_SOURCE")"/bl-log --no-act --log-level "$LOGLEVEL" --log-exit "$LOGEXITPRIO"
. "$(dirname "$BASH_SOURCE")"/bl-interactive --
. "$(dirname "$BASH_SOURCE")"/bl-security --

mrz_checkdigit() {
	local helpmsg="Usage: $FUNCNAME STRING [EXPECTED_RESULT]
If there is no second arg: output calculated check digit from [0-9A-Z<]* string
else return non-zero if EXPECTED_RESULT differs from calculated check digit.
"
	for ((;$#;)) ; do
		case "$1" in
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $PGPI_VERSION" ; return ;;
			--) shift ; break ;;
			-*) echo -e "$FUNCNAME: Error: Unrecognized option/parameters $1\n$helpmsg" >&2 ; return 2 ;;
			*) break ;;
		esac
	done

	local char sum=0 weight=(7 3 1)
	for ((i=0;i<${#1};i++)) ; do
		char=${1:$i:1}
		case $char in
			[0-9]) ((sum+=char*${weight[$((i%3))]})) ;;
			[A-Z]) ((sum+=($(printf "%d" "'$char'")-55)*${weight[$((i%3))]})) ;;
		esac
	done

	if ! [[ "$2" ]] ; then
		echo $((sum%10))
	else
		[[ "$2" == $((sum%10)) ]]
		return $?
	fi
}

mrz_analyse() {
	local helpmsg="Usage: $FUNCNAME AANAME MRZ
Analyse a Machine Readable Zone and fill the associative array named AANAME
"

	for ((;$#;)) ; do
		case "$1" in
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $PGPI_VERSION" ; return ;;
			--) shift ; break ;;
			-*) echo -e "$FUNCNAME: Error: Unrecognized option/parameters $1\n$helpmsg" >&2 ; return 2 ;;
			*) break ;;
		esac
	done

	local -n doc=$1
	shift
	local ch mrz=("$@")

	bl_log debug "mrz[0]= \"${mrz[0]}\""
	if [[ ${mrz[0]:0:1} != P ]] ; then
		bl_log debug "mrz[0]= \"${mrz[0]}\""
		bl_log warning "$FUNCNAME: unsupported. (not an ISO/IEC 7501-1 passport)"
		return 1
	fi
	bl_log debug "mrz[1]= \"${mrz[1]}\""
	if [[ ${#mrz[0]} != 44 ]] || [[ ${#mrz[1]} != 44 ]] ; then
		bl_log warning "$FUNCNAME: Invalid MRZ lenght ${#mrz[0]} ${#mrz[1]}"
		return 2
	fi

	doc=(
		[type]=${mrz[0]:0:2}
		[country]=${mrz[0]:2:3}
		[all_names]=${mrz[0]:5}
		[number]=${mrz[1]:0:9}
		[check_number]=${mrz[1]:9:1}
		[nationality]=${mrz[1]:10:3}
		[date_of_birth]=${mrz[1]:13:6}
		[check_date_of_birth]=${mrz[1]:19:1}
		[sex]=${mrz[1]:20:1}
		[expiration_date]=${mrz[1]:21:6}
		[check_expiration_date]=${mrz[1]:27:1}
		[personal_number]=${mrz[1]:28:14}
		[check_personal_number]=${mrz[1]:42:1}
		[composite]="${mrz[1]:0:10}${mrz[1]:13:7}${mrz[1]:21:20}"
		[check_composite]=${mrz[1]:43:1}
	)

	for ch in number date_of_birth expiration_date personal_number composite ; do
		doc[checked_$ch]=$(mrz_checkdigit "${doc[$ch]}")
		doc[valid_$ch]=$( [[ ${doc[checked_$ch]} == ${doc[check_$ch]} ]] && echo true || echo false )
		${doc[valid_$ch]} || bl_log warning "OBI WAN KENOBI ??? $ch checksum -> ${doc[check_$ch]}. Should be ${doc[checked_$ch]}."
	done

	doc[names]=$(echo $(echo "${doc[all_names]#*<<}" | tr '<' ' ') )
	doc[surname]=$(echo $(echo "${doc[all_names]%%<<*}" | tr '<' ' ') )
}

pgpi_gen_udid4() {
	local mrzn sname gname bdate bcountry c iso cname tohash1 tohash2
	local helpmsg="Usage: $FUNCNAME PARAMETERS...
Parameters:
    -s, --surname SURNAME            Surname/family name at birth
    -g, --given-names GIVEN_NAMES    Given names at birth
    -d, --birth-date BIRTH_DATE      Birth date
    -c, --birth-country COUNTRY_CODE Country code of birth place
    -p, --birth-place COORDINATES    Geographic coordinate of birth place
    -m, --mrz-names NAMES_IN_MRZ     SURNAME<<GIVEN<NAMES< as written in a Machine Readable Zone
If NAMES_IN_MRZ is given, SURNAME and GIVEN_NAMES are ignored.
If COUNTRY_CODE is given, COORDINATES is ignored
"
	for ((;$#;)) ; do
	case "$1" in
		-h|--h*) echo "$helpmsg" ; return ;;
		-V|--vers*) echo "$FUNCNAME $PGPI_VERSION" ; return ;;
		-m|--mrz-n*)
			shift
			mrzn=$1 ;;
		-s|--s*)
			shift
			sname=$(sed 's,[ ;,<-]\+,<,g'<<<"$1" )
			sname="${sname^^}"
			if ! (LC_CTYPE=C ; [[ "$sname" =~ ^[A-Z\<]+$ ]]) ; then
				bl_log error "$FUNCNAME: only [A-Z] characters allowed in $1"
				return 1
			fi ;;
		-g|--g*)
			shift
			gname=$(sed 's,[ ;,<-]\+,<,g'<<<"$1" )
			gname="${gname^^}<<"
			if ! (LC_CTYPE=C ; [[ "$gname" =~ ^[A-Z\<]+$ ]]) ; then
				bl_log error "$FUNCNAME: only [A-Z] characters allowed in $1"
				return 1
			fi ;;
		-d|--birth-d*)
			shift
			bdate=$1
			if ((${#1}<8)) ; then
				bdate="$(($(date +"%y%m%d") < bdate ? 19 : 20))$bdate"
				bl_log notice "$FUNCNAME: birth date '$1' is too short, assuming $bdate."
			fi
			if ! tohash2=$(date --date "$bdate" +"%Y-%m-%d" ) ; then
				bl_log error "$FUNCNAME: can't reformart birthdate $date"
				return 2
			fi ;;
		-c|--birth-c*)
			shift
			bcountry=$1 ;;
		-p|--birth-p*)
			shift
			#TODO: check if coordinate is valid (cf. Specifications)
			c="$1" ;;
		*) echo -e "$FUNCNAME: Error: Unrecognized option/parameters $1\n$helpmsg" >&2 ; return 2 ;;
	esac
	shift
	done
	[[ "$mrzn" ]] || mrzn="${sname}<<$gname"
	if ! tohash1=$(grep -o "[A-Z]\{1,32\}<<[A-Z]\{1,32\}<[A-Z]\{0,32\}<" <<<"$mrzn" ) ; then
		bl_log error "$FUNCNAME: no complete surname and given names extracted from $mrzn"
		return 1
	fi

	if [[ "$bcountry" ]] && read c iso cname < <(grep "	${bcountry^^}	" "$GEOLIST_CENTROID") ; then
		bl_log debug "$FUNCNAME: $c $iso $cname"
	else
		bl_log error "$FUNCNAME: no \"${bcountry}\" in $GEOLIST_CENTROID"
		return 3
	fi
	bl_log debug "$FUNCNAME: names: $tohash1"
	bl_log debug "$FUNCNAME: birthdate: $tohash2"
	echo "$(printf "$tohash1$tohash2" | md5sum | xxd -r -p | basenc --base64url | sed 's/==$//')$c"
}

pgpi_json_from_str() {
	local helpmsg="Usage: $FUNCNAME [STRING]...
"'Escape "\" and [/"\b\f\n\r\t] characters as required by JSON format.
If there is no STRING in command line, read it from stdin.
'

	for ((;$#;)) ; do
		case "$1" in
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $PGPI_VERSION" ; return ;;
			--) shift ; break ;;
			-*) echo -e "$FUNCNAME: Error: Unrecognized option/parameters $1\n$helpmsg" >&2 ; return 2 ;;
			*) break ;;
		esac
	done

	local from='cat'
	(($#)) && from='eval echo "$@"'
	$from | sed 's,\\,\\\\,g; s,/,\\/,g; s,",\\",g; s,\x08,\\b,g; s,\x0c,\\f,g; s,\r,\\r,g; s,\t,\\t,g;' | sed ':a;N;$!ba; s,\n,\\n,g;'
}

pgpi_json_from_var() {
	local nested=false shft=0
	local helpmsg="Usage: $FUNCNAME [OPTIONS] VARNAME
Output content of VARNAME in a JSON format.

Options:
    -n, --nested        Assume any value beginning with \"declare -[aA]\" are nested data to be translate to JSON format
    -s, --shift NUMBER  Number of tabs shifting of each line (default $shft)
"
#TODO: one more options to display non-associative array as json array, and to manage arrays with non-contiguous indices.
#TODO: ... Maybe a selector <on|auto|off>, whith 'auto' to detect if array indices are non-contiguous.
	for ((;$#;)) ; do
		case "$1" in
			-n|--nest*) nested=true ;;
			-s|--shift) shift ; shft=$(($1)) ;;
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $PGPI_VERSION" ; return ;;
			--) shift ; break ;;
			-*) echo -e "$FUNCNAME: Error: Unrecognized option/parameters $1\n$helpmsg" >&2 ; return 2 ;;
			*) break ;;
		esac
		shift
	done

	local lb notstarted=true
	local -n aa=$1
	((shft)) && lb=$(eval printf '\\t%.0s' {1..$shft})
	printf "$lb{\n"
	for i in "${!aa[@]}"; do
		$notstarted || printf ",\n"
		notstarted=false
		#TODO: Maybe use and depend on "jq". cf. https://stackoverflow.com/questions/44792241/constructing-a-json-hash-from-a-bash-associative-array
		if $nested && [[ "${aa[$i]}" =~ ^declare" "-[Aa][a-zA-Z]*" "([a-zA-Z_][a-zA-Z0-9_]*)= ]] ; then
			local "${BASH_REMATCH[1]}"
			eval "${aa[$i]}"
			echo -n "$lb	\"$(pgpi_json_from_str -- "$i")\":"$'\n'"$(pgpi_json_from_var --nested --shift $((shft+2)) "${BASH_REMATCH[1]}")"
		else
			echo -n "$lb	\"$(pgpi_json_from_str -- "$i")\": \"$(pgpi_json_from_str -- "${aa[$i]}")\""
		fi
	done
	printf "\n$lb}\n"
}

# Do nothing else if sourced
[[ "$BASH_SOURCE" == "$0" ]] || return 0


### Init ###

#_onexit() {
#	[[ -d "$TMPDIR" ]] && rm -rvf "$TMPDIR" | bl_log info
#}
#
#TMPDIR=$(mktemp -d -t "$PGPI_NAME".XXXXXX) || log crit "crit: Can not create a safe temporary directory."
#
#trap _onexit EXIT

### Run ###

imgfile="$1"
if [[ "$2" ]] ; then
	shift
	bl_log warning "ignoring extra args $@"
fi

if ! [[ "$imgfile" ]] ; then
	if $ONLYUDID ; then
		declare -A PGPID
		while true ; do
			PGPID[birth_surname]=$(bl_input --default "${PGPID[birth_surname]^^}" "Birth surname")
			PGPID[birth_names]=$(bl_input --default "${PGPID[birth_names]}" "Birth names")
			PGPID[birth_date]=$(bl_input --default "${PGPID[birth_date]}" "Birth date")
			PGPID[birth_country]=$(bl_input --default "${PGPID[birth_country]}" "Birth country")

			! bl_yesno --default=no --text \
"
Surname at birth:     ${PGPID[birth_surname]^^}
Given names at birth: ${PGPID[birth_names]}
Date of birth:        ${PGPID[birth_date]}
Country of birth:     ${PGPID[birth_country]}
" \
				"Is that correct" || break
		done

		printf "udid4="
		pgpi_gen_udid4 --surname "${PGPID[birth_surname]}" --given-names "${PGPID[birth_names]}" --birth-date "${PGPID[birth_date]}" --birth-country "${PGPID[birth_country]}"
		exit $?
	else
		v4ldevices=($(ls /dev/v4l/by-id/*index0)) || bl_log crit "No image file given and no video input (eg. webcam) detected"
		v4lchoosed=$(bl_chooseinlist --num-per-line 1 --text "No Image file given, device to take picture of a face or an ID card ?" "${v4ldevices[@]}")
		v4ldevice="$(readlink -f "${v4ldevices[$((v4lchoosed-1))]}")"
		ffplay -loglevel warning -video_size 1024x768 -i "$v4ldevice" & sleep 3 ; kill $!
		bl_log notice "Taking picture, please don't move (2 seconds) !"
		ffmpeg -loglevel error -y -ss 00:02 -video_size 1024x768 -i "$v4ldevice" -frames:v 1 -q:v 2 v4l.jpg
		#fswebcam --no-banner --resolution 1024x768 --skip 40 --frame 3 --set lights=on --device "$v4ldevice" v4l.jpg 2> >(bl_log notice)
		#gm display -immutable v4l.jpg 2> >(bl_log info) & sleep 1 ; kill $!
		while ! facedetect -q v4l.jpg 2> >(bl_log notice) ; do
			bl_log notice "No face detected..."
			ffplay -loglevel warning -video_size 1024x768 -i "$v4ldevice" & sleep 3 ; kill $!
			bl_log notice "Taking picture, please don't move (2 seconds) !"
			ffmpeg -loglevel error -y -ss 00:02 -video_size 1024x768 -i "$v4ldevice" -frames:v 1 -q:v 2 v4l.jpg
		done
		imgfile="v4l.jpg"
	fi
fi

#scanimage -l 2 -t 2 -x 120 -y 170 --mode Color --resolution 200 --format=tiff > tmpimg.tiff

facep=$(facedetect --best -- "$imgfile" 2> >(bl_log notice) || true )
[[ "$facep" ]] || bl_log crit "No face detected in $imgfile"

read px py sx sy etc <<<"$facep"
mx=$((sx*$FACE_MARGIN_WIDTH))
my=$((sy*$FACE_MARGIN_HEIGHT))
bl_log info "$imgfile face -> position: +$px+$py  size: ${sx}x$sy  marges: +${mx}+$my"

declare -A DOCUMENT=()
# OCR only on zone below the image, converted to PNG because tesseract work better whith this format.
if mrz=($(gm convert -crop +0+$((py+sy)) "$imgfile" png:- 2> >(bl_log notice) | tesseract --tessdata-dir "$TESSDATADIR" -l mrz - - 2> >(bl_log notice) | sed 's/[^0-9A-Z<]*//g' | grep -m1 -A2 "<<")) ; then
	if mrz_analyse DOCUMENT "${mrz[@]}" ; then
		#WARNING: mrz data may be irrelevant to generate udid4. eg:
		#         * Surname or given names may be incomplete (cut bc exceed mrz size)
		#         * Surname or given names may differs from those given at birth (marriage, gender change, etc.)
		#         * Surname or given names transliteration may have change over time
		#         * Year of birth date is not written with 4 digit (and people may live longer than 100 years)
		#         * Humans may have done error on birth date, surname or given names.
		if ! DOCUMENT[udid4_auto]=$(pgpi_gen_udid4 --mrz-names "${DOCUMENT[all_names]}" --birth-date "${DOCUMENT[date_of_birth]}" --birth-country "${DOCUMENT[nationality]}") ; then
			bl_log warning "can't generate an udid4 from mrz data"
			unset DOCUMENT[udid4_auto]
		fi
	else
		bl_log warning "$imgfile: Invalid or unsupported machine-readable zone"
	fi
else
	bl_log warning "$imgfile: No machine-readable zone detected"
fi

DOCUMENT[filename]=$imgfile
DOCUMENT[face_scan_64url]=$(gm convert -crop $((sx+mx))x$((sy+my))+$((px-(mx/2)))+$((py-(my/2))) "$imgfile" jpeg:- 2> >(bl_log warning) | basenc --base64url )
if ((${#DOCUMENT[face_scan_64url]} < 2048 )) ; then
	bl_log error "$outdir/face.jpg: too small (${#DOCUMENT[face_scan_64url]} < 2048)"
elif ((${#DOCUMENT[face_scan_64url]} > (1<<16) )) ; then
	bl_log error "$outdir/face.jpg: too big (${#DOCUMENT[face_scan_64url]} > $((1<<16)))"
fi

declare -A PGPID=()

PGPID[document0]="$(declare -p DOCUMENT)"

PGPID[birth_date]=$(date --date "$(($(date +"%y%m%d") < DOCUMENT[date_of_birth] ? 19 : 20))${DOCUMENT[date_of_birth]}" +"%Y-%m-%d")
while true ; do
	! bl_yesno --default=no --text \
"
Surname at birth:     ${PGPID[birth_surname]:=${DOCUMENT[surname]}}
Given names at birth: ${PGPID[birth_names]:=${DOCUMENT[names]}}
Date of birth:        ${PGPID[birth_date]}
Country of birth:     ${PGPID[birth_country]:=${DOCUMENT[nationality]}}
" \
		"Is that correct" || break

	PGPID[birth_surname]=$(bl_input --default "${PGPID[birth_surname]^^}" "Birth surname")
	PGPID[birth_names]=$(bl_input --default "${PGPID[birth_names]}" "Birth names")
	PGPID[birth_date]=$(bl_input --default "${PGPID[birth_date]}" "Birth date")
	PGPID[birth_country]=$(bl_input --default "${PGPID[birth_country]}" "Birth country")
done

if PGPID[udid4]=$(pgpi_gen_udid4 --surname "${PGPID[birth_surname]}" --given-names "${PGPID[birth_names]}" --birth-date "${PGPID[birth_date]}" --birth-country "${PGPID[birth_country]}") ; then
	bl_log info "udid4=${PGPID[udid4]}"
else
	bl_log crit "can't generate an udid4 from data you have validated"
fi

outdir="${PGPI_OUTPATH%/}/${PGPID[udid4]}"
mkdir -p "$outdir"
cp -bvf "$imgfile" "$outdir/document.orig" 2> >(bl_log warning) | bl_log info

# Resize and display scanned face
(exec 2> >(bl_log error) ; basenc --base64url --decode <<<"${DOCUMENT[face_scan_64url]}" | gm convert -geometry x180 - "$outdir/face.jpg" )
bl_log notice "Displaying face... close it to continue !"
gm display -immutable "$outdir/face.jpg" 2> >(bl_log error)

bl_yesno "Did the image correspond to ${PGPID[birth_names],,} ${PGPID[birth_surname]^^}"
PGPID[face1_64url]=$(basenc --base64url < "$outdir/face.jpg")

if $ONLYUDID ; then
	echo "udid4=${PGPID[udid4]}"
	pgpi_json_from_var --nested PGPID > "$outdir/pgpid.json" 2> >(bl_log crit)
	exit
fi

while true ; do
	while true ; do
		PGPID[email]=$(bl_input --default "${PGPID[email]}" "Public email adress")
		grep -q "^[^@[:space:]]\+@[^.[:space:]]\+\.[^[:space:]]\+$" <<<"${PGPID[email]}" && break
	done

	PGPID[pseudonym]=$(bl_input --default "${PGPID[pseudonym]}" "Public name (or pseudonym)")
	! bl_yesno --text \
"
Public name (or pseudonym): ${PGPID[pseudonym]}
Public email adress:        ${PGPID[email]}
" \
		"Is that correct" || break
done

PGPID[wkd_uri]=$($(gpgconf --list-dirs libexecdir)/gpg-wks-client --print-wkd-url "${PGPID[email]}" 2> >(bl_log warning) )
PGPID[wks_support]=$(timeout --verbose 5s $(gpgconf --list-dirs libexecdir)/gpg-wks-client --supported --with-colons "${PGPID[email]}" 2> >(bl_log notice) || true )

if ! [[ "${PGPID[wks_support]}" =~ :1: ]] ; then
	#TODO: Improve parsing wks_support and distinct WKD and WKS (and later WKS versions)
	bl_log warning "Your email provider support neither WKD or WKS protocol :-("
fi


PGPID[passphrase]="$(bl_gen_passphrase --interactive)"

PGPID[hkp_server]="foopgp.org:11371"
pgpi_json_from_var --nested PGPID > "$outdir/pgpid.json" 2> >(bl_log crit)

#TODO: check gpg version, because we use some recent feature, and compatibility may change (tested with gpg (GnuPG) 2.2.27 libgcrypt 1.8.8)
# Remove previous gnupg temp dir, if present.
if [[ -d "$outdir/gnupg" ]] ; then
	bl_shred_path -v -f -r "$outdir/gnupg" 2> >(bl_log warning) | bl_log debug
fi
mkdir -p "$outdir/gnupg"
chmod -R go-rwx "$outdir"

cat >"$outdir/gnupg/gpg.genkey.batch" <<EOF
%echo Generating OpenPGP key for ${PGPID[pseudonym]}
Key-Type: eddsa
Key-Curve: Ed25519
Key-Usage: cert sign
Subkey-Type: ecdh
Subkey-Curve: Curve25519
Subkey-Usage: encrypt
Name-Real: ${PGPID[pseudonym]}
Name-Comment: udid4=${PGPID[udid4]}
Name-Email: ${PGPID[email]}
Expire-Date: $(date -I -d "+11 years")
Passphrase: ${PGPID[passphrase]}
Keyserver: hkp://${PGPID[hkp_server]}
# Do a commit here, so that we can later print "done" :-)
%commit
EOF
if ! gpg --homedir "$outdir/gnupg" --batch --generate-key --allow-freeform-uid "$outdir/gnupg/gpg.genkey.batch" 2> >(bl_log notice) ; then
	bl_log crit "gpg --generate-key FAIL ($?)"
fi

# get first 2 fprs
FPRS=($(gpg --homedir "$outdir/gnupg" --list-secret-keys --with-colons 2> >(bl_log notice) | sed -n 's,^fpr:.*:\([[:xdigit:]]\{40\}\):,\1,p'))
PGPID[pubkey_uri]="http://${PGPID[hkp_server]}/pks/lookup?search=${FPRS[0]}&op=get"

# Add photo
if ! gpg --homedir "$outdir/gnupg" --command-fd 0 --batch --with-colons --pinentry-mode loopback --passphrase "${PGPID[passphrase]}" --edit-key ${FPRS[0]} 1> >(bl_log debug) 2>&1 <<<"addphoto
$outdir/face.jpg
y
save
" ; then
	bl_log crit "Adding photo ID to OpenPGP certificate FAIL ($?)"
fi

bl_log info "Generate auth key to be put in OpenPGP card..."
gpg --homedir "$outdir/gnupg" --batch --passphrase "${PGPID[passphrase]}" --pinentry-mode loopback --quick-add-key ${FPRS[0]} ed25519 auth 11y 2> >(bl_log notice)
bl_log info "Generate extra signing keys..."
gpg --homedir "$outdir/gnupg" --batch --passphrase "${PGPID[passphrase]}" --pinentry-mode loopback --quick-add-key "${FPRS[0]}" ed25519 sign 11y 2> >(bl_log notice)
gpg --homedir "$outdir/gnupg" --batch --passphrase "${PGPID[passphrase]}" --pinentry-mode loopback --quick-add-key "${FPRS[0]}" ed25519 sign 11y 2> >(bl_log notice)
gpg --homedir "$outdir/gnupg" --batch --passphrase "${PGPID[passphrase]}" --pinentry-mode loopback --quick-add-key "${FPRS[0]}" ed25519 sign 11y 2> >(bl_log notice)

# updates array of fingerprints
FPRS=($(gpg --homedir "$outdir/gnupg" --list-secret-keys --with-colons 2> >(bl_log notice) | sed -n 's,^fpr:.*:\([[:xdigit:]]\{40\}\):,\1,p'))
PGPID[frps]="$(declare -p FPRS)"
pgpi_json_from_var --nested PGPID > "$outdir/pgpid.json" 2> >(bl_log crit)

bl_log info "Export OpenPGP first certificate and public ssh key..."
gpg --homedir "$outdir/gnupg" --export 2> >(bl_log crit) > "$outdir/PGPcert.gpg"
gpg --homedir "$outdir/gnupg" --export-ssh-key ${FPRS[0]} 2> >(bl_log crit) > "$outdir/ssh_${PGPID[udid4]}.pub"
bl_log info "Prepare paper to backup master key, and export secret subkeys..."
umask 0077
gpg --homedir "$outdir/gnupg" --batch --passphrase "${PGPID[passphrase]}" --pinentry-mode loopback --export-secret-keys ${FPRS[0]}\! 2> >(bl_log crit) | paperkey 2> >(bl_log crit) > "$outdir/secret.paper.txt"
printf "\n# Initial passphrase: ${PGPID[passphrase]}\n" >> "$outdir/secret.paper.txt"
gpg --homedir "$outdir/gnupg" --batch --passphrase "${PGPID[passphrase]}" --pinentry-mode loopback --armor --export-secret-keys ${FPRS[1]}\! 2> >(bl_log crit) > "$outdir/secret.E.asc"
gpg --homedir "$outdir/gnupg" --batch --passphrase "${PGPID[passphrase]}" --pinentry-mode loopback --armor --export-secret-keys ${FPRS[2]}\! 2> >(bl_log crit) > "$outdir/secret.A.asc"
bl_log info "export secret sub-keys to be use in thunderbird, delta chat, etc..."
gpg --homedir "$outdir/gnupg" --batch --passphrase "${PGPID[passphrase]}" --pinentry-mode loopback --armor --export-secret-keys ${FPRS[3]}\! 2> >(bl_log crit) > "$outdir/secret.S1.asc"
gpg --homedir "$outdir/gnupg" --batch --passphrase "${PGPID[passphrase]}" --pinentry-mode loopback --armor --export-secret-keys ${FPRS[1]}\! ${FPRS[4]}\! 2> >(bl_log crit) > "$outdir/secret.S2+E.asc"
gpg --homedir "$outdir/gnupg" --batch --passphrase "${PGPID[passphrase]}" --pinentry-mode loopback --armor --export-secret-keys ${FPRS[1]}\! ${FPRS[5]}\! 2> >(bl_log crit) > "$outdir/secret.S3+E.asc"

# log some info
gpg --quiet --homedir "$outdir/gnupg" --list-keys > >(bl_log info) 2> >(bl_log warning)

for ((i=0;;i++)) ; do
	while ! gpg --homedir "$outdir/gnupg" --card-status > >(bl_log info) 2> >(bl_log notice) ; do
		sleep 1
		bl_msgstop "Please plug an OpenPGP card or dongle..."
	done
	bl_yesno "Factory reset OpenPGP card (This will destroys all OpenPGP keys stored on the card!)" || continue

	echo "admin
factory-reset
y
yes
quit" | gpg --homedir "$outdir/gnupg" --command-fd 0 --batch --with-colons --card-edit 1> >(bl_log debug) 2>&1 || bl_log crit "Factory Reset OpenPGP card FAIL ($?)"

	echo "admin
login
${PGPID[pseudonym]}
name
${PGPID[pseudonym]}

quit" | gpg --homedir "$outdir/gnupg" --command-fd 0 --batch --with-colons --pinentry-mode loopback --passphrase "12345678" --card-edit 1> >(bl_log debug) 2>&1 || bl_log crit "Setting OpenPGP card holder FAIL ($?)"

	echo "admin
key-attr
2
1
2
1
2
1
quit" | gpg --homedir "$outdir/gnupg" --command-fd 0 --batch --with-colons --pinentry-mode loopback --passphrase "12345678" --card-edit 1> >(bl_log debug) 2>&1 || bl_log crit "Setting OpenPGP card keys attributes FAIL ($?)"

	echo "admin
url
${PGPID[pubkey_uri]}
quit" | gpg --homedir "$outdir/gnupg" --command-fd 0 --batch --with-colons --pinentry-mode loopback --passphrase "12345678" --card-edit 1> >(bl_log debug) 2>&1 || bl_log crit "Setting Pubkey URL in OpenPGP card FAIL ($?)"

	bl_log info "Reimport secret key to be moved with keytocard..."
	gpg --homedir "$outdir/gnupg" --batch --command-fd 0 --pinentry-mode loopback --yes --delete-secret-keys ${FPRS[0]}\! ${FPRS[1]}\! ${FPRS[2]}\!
	gpg --homedir "$outdir/gnupg" --command-fd 0 --batch --pinentry-mode loopback --passphrase "${PGPID[passphrase]}" --import 2> >(bl_log notice) < <(paperkey --pubring "$outdir/PGPcert.gpg" --secrets "$outdir/secret.paper.txt" 2> >(bl_log crit) )
	gpg --homedir "$outdir/gnupg" --command-fd 0 --batch --pinentry-mode loopback --passphrase "${PGPID[passphrase]}" --import 2> >(bl_log info) <"$outdir/secret.E.asc"
	gpg --homedir "$outdir/gnupg" --command-fd 0 --batch --pinentry-mode loopback --passphrase "${PGPID[passphrase]}" --import 2> >(bl_log info) <"$outdir/secret.A.asc"

	bl_log notice "Unfortunately, we can't automatize moving key to card, then you should move keys master 1 and 2 manualy..."
	bl_log notice "Note: password is now set to 'm' to ease this manual operation."
	printf "${PGPID[passphrase]}\nm\n" | gpg --homedir "$outdir/gnupg" --command-fd 0 --batch --pinentry-mode loopback --change-passphrase ${FPRS[0]} 1> >(bl_log notice) 2>&1 || true
	gpg --homedir "$outdir/gnupg" --edit-key "${FPRS[0]}" || bl_log warning "Moving OpenPGP keys to card returns $?"
	#printf "m\n${PGPID[passphrase]}\n" | gpg --homedir "$outdir/gnupg" --command-fd 0 --batch --pinentry-mode loopback --change-passphrase ${FPRS[0]} 1> >(bl_log crit) 2>&1

	declare -A OPGPCARD=()
	while IFS=':' read key value ; do
		case "$key" in
			[Rr]eader|version|vendor|serial)
				OPGPCARD[${key,,}]="$value" ;;
		esac
	done < <(gpg --homedir "$outdir/gnupg" --card-status --with-colons)
	PGPID[card$i]="$(declare -p OPGPCARD)"

	bl_yesno "Do you have an Other OpenPGP card to set up identically" || break

done

bl_shred_path -v -f "$outdir/gnupg" 2> >(bl_log warning) | bl_log debug
pgpi_json_from_var --nested PGPID > "$outdir/pgpid.json" 2> >(bl_log crit)

#lpr < "$outdir/secret.paper.txt"
#shred -u "$outdir/secret.paper.txt"

exit 0
