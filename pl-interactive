#!/bin/bash
#
# Copyright © 2021 b Jean-Jacques Brucker <jjbrucker@free.fr>
#          Confidential - All Right Reserved
#
# Bash library and executable that help managing interactive choice
#
# TODO: complete completion

if [[ "$1" == --bash-completion ]] ; then
	_pl_interactive_completion()
	{
		local cur prev coptions="--help --version --"
		local IFS=$'\n'

		COMPREPLY=()
		cur=${COMP_WORDS[COMP_CWORD]}

		if grep -q -- "\(--version\|--help\)\>" <<< "${COMP_WORDS[@]}" ; then
			# some options will exit without executing any actions, so don't complete anything
			return
		elif grep -q "\<yesno\>" <<< "${COMP_WORDS[@]}" ; then
			COMPREPLY=( $(IFS=" " compgen -W "$coptions --default=yes --default=no --preamble" -- $cur ) )
		elif grep -q "\<chooseinlist\>" <<< "${COMP_WORDS[@]}" ; then
			COMPREPLY=( $(IFS=" " compgen -W "$coptions --num-per-line --preamble" -- $cur ) )
		else
			COMPREPLY=( $(IFS=" " compgen -W "$coptions yesno chooseinlist" -- $cur ) )
		fi
	}
	complete -o filenames -F _pl_interactive_completion "$BASH_SOURCE"
	return 0
fi

# If sourcing while _pl_interactive_parseoptions is already set, execute the function and return without reloading rest of file.
if [[ "$BASH_SOURCE" != "$0" ]] && [[ "$(type -t _pl_interactive_parseoptions)" == function ]] ; then
	_pl_interactive_parseoptions "$@"
	return $?
fi


### Constants ###

declare -r PL_INTERACTIVE_NAME="$(basename $(readlink -f "$BASH_SOURCE") )"
declare -r PL_INTERACTIVE_VERSION="0.0.1"


### functions ###

_pl_interactive_parseoptions() {
	for ((;$#;)) ; do
		case "$1" in
			-h|--h*) printf "$PL_INTERACTIVE_usage\n$PL_INTERACTIVE_chelpmsg\n$PL_INTERACTIVE_shelpmsg\n" ; return 2 ;;
			-V|--vers*) printf "$PL_INTERACTIVE_NAME $PL_INTERACTIVE_VERSION\n" ; return 2 ;;
			--) shift ; break ;;
			-*) printf "$PL_INTERACTIVE_NAME: unrecognized option '$1'\n$PL_INTERACTIVE_usage\nTry '$BASH_SOURCE --help' for more information.\n" >&2 ; return 2 ;;
			*) break ;;
		esac
		shift
	done
}


pl_yesno() {
	local name
	((PL_INTERACTIVE_isprogram)) && name="$PL_INTERACTIVE_NAME ${FUNCNAME:3}" || name="$FUNCNAME"
	local usage="Usage: $name [OPTIONS] QUESTION"
	local helpmsg="
Helper for a yes/no question (binary choice)
If REPLY == 'yes', return 0
If REPLY == 'no', return 1
Else loop asking the question.

Options:
      --default=<yes|no>   Set a default answer
  -p, --preamble TEXT      Text to display before the question
"
	local def pr question
	for ((;$#;)) ; do
		case "$1" in
			--default=yes) def="yes" ;;
			--default=no) def="no" ;;
			-p|--pre*) shift ; pr="$1" ;;
			-h|--h*) printf "%s\n%s\n" "$usage" "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $PL_INTERACTIVE_VERSION" ; return ;;
			--) shift ; break ;;
			-*) printf "$FUNCNAME: Error: unrecognized option '%s'\nTry '$name --help' for more information.\n" "$1" >&2 ; return 2 ;;
			*) break ;;
		esac
		shift
	done
	question=" $@ (y/n)"
	[[ -z "$def" ]] || question+=" [$def]"

	while true ; do
		echo "$pr" >&2
		read -p " $question ? " rep
		rep=${rep:-$def}
		case "${rep,,}" in
		  y|yes|oui|'sí'|ja|si|'да')
			return 0 ;;
		  n|no|non|nein|'нет')
			return 1 ;;
		  *) echo "  please answer \"yes\" or \"no\"" >&2 ;;
		esac
	done
}


pl_chooseinlist() {
	local name
	((PL_INTERACTIVE_isprogram)) && name="$PL_INTERACTIVE_NAME ${FUNCNAME:3}" || name="$FUNCNAME"
	local usage="Usage: $name [OPTIONS] ITEMS..."
	local helpmsg="
Helper for a single choice in a list (like radiobutton)
Display (stderr) numbered list of item and loop asking for a number in this list
Then echo (stdout) selected number (1-n).

Options:
  -p, --preamble     TEXT    Text/Question to display before the list
  -n, --num-per-line NUMBER  Number of items per line (default: 3)
"
	local pr nperline=3 n i ret=0
	for ((;$#;)) ; do
		case "$1" in
			-p|--pre*) shift ; pr="$1" ;;
			-n|--num*) shift ; nperline="$1" ;;
			-h|--h*) printf "%s\n%s\n" "$usage" "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $PL_INTERACTIVE_VERSION" ; return ;;
			--) shift ; break ;;
			-*) printf "$FUNCNAME: Error: unrecognized option '%s'\nTry '$name --help' for more information.\n" "$1" >&2 ; return 2 ;;
			*) break ;;
		esac
		shift
	done
	n=$#
	((n)) || { printf "$FUNCNAME: Error: need items\nTry '$name --help' for more information.\n" >&2 ; return 1 ; }
	printf "$pr" >&2
	for ((i=0;i<n;)) ; do
		if ((i%nperline)) ; then
			printf "\t\t" >&2
		else
			printf "\n\t" >&2
		fi
		printf "$((++i))) $1" >&2
		shift
	done
	echo >&2
	while ((ret<1 || ret>n)) ; do
		read -p "Reply (1-$n) ? " ret
	done
	echo $ret
}


### Help Messages (and set -e if program) ###

if [[ "$BASH_SOURCE" == "$0" ]] ; then
	# run as a program
	set -e
	declare -r PL_INTERACTIVE_isprogram=1

	PL_INTERACTIVE_usage="Usage: $BASH_SOURCE [OPTIONS]... ACTION [ACTION_ARGUMENTS]..."
	PL_INTERACTIVE_shelpmsg="
Actions:
$(for f in $(sed -n 's,^\(pl_[^(]*\)().*, \1,p' "$BASH_SOURCE") ; do printf "   %-19s%s\n" "${f:3}" "$($f --help | sed -n '/^$/{n;p;q}')" ; done)

$PL_INTERACTIVE_NAME is also bash library, see:
$ source $BASH_SOURCE --help"
else
	# run as a library (source $0)

	PL_INTERACTIVE_usage="Usage: source $BASH_SOURCE [OPTIONS]..."

	PL_INTERACTIVE_shelpmsg="
      --bash-completion    set completion for $BASH_SOURCE program and return (without loading anything else)

Functions:
$(for f in $(sed -n 's,^\(pl_[^(]*\)().*, \1,p' "$BASH_SOURCE") ; do printf "   %-19s%s\n" "$f" "$($f --help | sed -n '/^$/{n;p;q}')" ; done)

Reminder: when used as a library, all functions calls share the same environment variables, i.e. the same global options."
fi

PL_INTERACTIVE_chelpmsg="
Options:
  -h, --help               show this help and exit (or return)
  -V, --version            show version and exit (or return)"


### Init ###

# Parse Options
_pl_interactive_parseoptions "$@"

# Do nothing else if sourced
[[ "$BASH_SOURCE" == "$0" ]] || return 0


### Run ###

if grep -q "^pl_$1()" "$BASH_SOURCE" ; then
	function="pl_$1"
	shift
	$function "$@"
	exit $?
else
	printf "$PL_INTERACTIVE_NAME: unrecognized action '$1'\n$PL_INTERACTIVE_usage\nTry '$BASH_SOURCE --help' for more information.\n" >&2
	exit 2
fi

