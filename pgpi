#!/bin/bash
#
# Copyright Â© 2021 by Friends Of OpenPGP organization.
#          Confidential - All Right Reserved
#
# Extract MRZ data and photo from ID documents (eg: International Passeports)
# to generate OpenPGP certificates and keys to be imported for multiple applications (mail, chat, vote, etc.).
# May also move or copy 3 importante keys (SC, E and A) to OpenPGP Security hardware (nitrokeys, yubikeys, etc.)
#

if [[ "$1" == --bash-completion ]] ; then
	_pgpi_completion()
	{
		local cur prev options
		local IFS=$'\n'

		COMPREPLY=()
		cur=${COMP_WORDS[COMP_CWORD]}

		if [[ "$cur" == -* ]]; then
			options="--syslog --output-path --json --hurry --verbose --quiet --help --version"

			COMPREPLY=( $(IFS=" " compgen -W "$options" -- $cur ) )
		else
			prev=${COMP_WORDS[COMP_CWORD-1]}
			case $prev in
				-o|--output-path)
					COMPREPLY=( $(compgen  -d -- $cur ) )
					return ;;
				# some options will exit without executing any actions, so don't complete anything
				-h|--help|-V|--version)
					return ;;
			esac

			COMPREPLY=( $(compgen -o plusdirs -f -X '!*.@(gif|GIF|jp?(e)g|JP?(E)G|miff|tif?(f)|pn[gm]|PN[GM]|p[bgp]m|bmp|BMP|xpm|ico|xwd|tga|pcx)' -- $cur ) )
		fi
	}
	complete -o filenames -F _pgpi_completion "$BASH_SOURCE"
	return 0
fi

PGPI_NAME="$(basename $(readlink -f "$BASH_SOURCE") )"
PGPI_VERSION="0.0.1"

### Constants ###

FACE_MARGIN_WIDTH="25/100"
FACE_MARGIN_HEIGHT="50/100"
TESSDATADIR="$(dirname "$0")/data/"
GEOLIST_CENTROID="$(dirname "$0")/data/geolist_centroid.txt"

declare -A loglevels=(
[emerg]=0
[alert]=1
[crit]=2
[error]=3 # deprecated synonym for err
[err]=3
[warning]=4
[notice]=5
[info]=6
[debug]=7)


### Default option values ###

PGPI_LOGCMD="_log -Q"

if [[ "$BASH_SOURCE" == "$0" ]] ; then
	# run as a program
	set -e
	# set global constants real constant (read only)
	declare -r FACE_MARGIN_WIDTH FACE_MARGIN_HEIGHT TESSDATADIR GEOLIST_CENTROID loglevels
	_exit="exit"
	LOGEXITPRIO=crit
	LOGLEVEL=5

	PGPI_OUTPATH="$PWD"
	PGPI_OUTPUTJSON=false
	PGPI_INTERACTIVE=true

	usage="Usage: $BASH_SOURCE [OPTIONS]... [--] IMAGES...
If $PGPI_NAME succeed, it will create a subdirectories containing all generated files."

	soptions="
    -o, --output-path PATH   emplacement for generated subdirs and files (current: $PGPI_OUTPATH )
    -j, --json               don't generate OpenPGP stuff, but only output json (like 'mrz' from PassportEye)
    -H, --hurry              don't be interactive : don't ask anything but loose features and robustness.
    -v, --verbose            increase log verbosity: ...<notice[5]<info[6]<debug[7]  (current: $LOGLEVEL)
    -q, --quiet              decrease log verbosity: ...<err[3]<warning[4]<notice[5]<...  (current: $LOGLEVEL)
    -h, --help               show this help and exit
    -V, --version            show version and exit"
else
	# run as a library (source $0)
	_exit="true"
	LOGEXITPRIO=emerg
	LOGLEVEL=6

	usage="Usage: source $BASH_SOURCE [OPTIONS]..."

	soptions="
        --bash-completion    set completion for $BASH_SOURCE program and return (without loading anything else)
    -l, --log-level LEVEL    log level: emerg<1=alert<crit<3=err<warning<5=notice<info<7=debug (current: $LOGLEVEL)
    -h, --help               show this help
    -V, --version            show version"
fi

### Handling options ###

helpmsg="$usage

Options:
    -L, --log-exit PRIORITY  log exit priority: emerg|alert|crit|err|warning|... (current: $LOGEXITPRIO )
    -s, --syslog             write also logs to the system logs
$soptions
"

for ((i=0;$#;)) ; do
case "$1" in
	-o|--output*) shift ; PGPI_OUTPATH="$1" ; ( cd "$PGPI_OUTPATH" && touch . ) ;;
	-l|--log-l*) shift ; LOGLEVEL="$1" ; [[ "$LOGLEVEL" == [0-9] ]] || { echo -e "Error: log-level out of range [0-7]" >&2 ; $_exit 2 ; } ;;
	-L|--log-e*) shift ; LOGEXITPRIO="$1"
		grep -q "\<$LOGEXITPRIO\>" <<<${!loglevels[@]} || { echo -e "Error: log-exit \"$LOGEXITPRIO\" is none of: ${!loglevels[@]}" >&2 ; $_exit 2 ; } ;;
	-v|--verb*) ((LOGLEVEL++)) ;;
	-q|--quiet) ((LOGLEVEL--)) ;;
	-s|--syslog) PGPI_LOGCMD="_log" ;;
	-j|--json) PGPI_OUTPUTJSON=true ;;
	-H|--hurry) PGPI_INTERACTIVE=false ;;
	-h|--h*) echo "$helpmsg" ; $_exit ;;
	-V|--vers*) echo "$PGPI_NAME $PGPI_VERSION" ; $_exit ;;
	--) shift ; break ;;
	-*) echo -e "Error: Unrecognized option $1\n$helpmsg" >&2 ; $_exit 2 ;;
	*) break ;;
esac
shift
done


### functions ###

_log() {
	local helpmsg="Usage: $FUNCNAME [OPTIONS]... PRIORITY [MESSAGE]...
PRIORITY list: $(declare -p loglevels)
If level[PRIORITY] is under LOGLEVEL=$LOGLEVEL, don't log anything.
If PRIORITY is more serious than LOGEXITPRIO=$LOGEXITPRIO, exit(8+level[PRIORITY])
If there is no MESSAGE in command line, read it from stdin.

$FUNCNAME specific options:
 -q, --quiet              do not output message to standard error
 -Q, --no-act             do not send message to the logs system (syslog)

Options forwarded to 'logger':
 -f, --file <file>        log the contents of this file
 -e, --skip-empty         do not log empty lines when processing files
     --octet-count        use rfc6587 octet counting
     --prio-prefix        look for a prefix on every line read from stdin
 -S, --size <size>        maximum size for a single message
 -n, --server <name>      write to this remote syslog server
 -P, --port <port>        use this port for UDP or TCP connection
 -T, --tcp                use TCP only
 -d, --udp                use UDP only
     --rfc3164            use the obsolete BSD syslog protocol
     --rfc5424[=<snip>]   use the syslog protocol (the default for remote);
                            <snip> can be notime, or notq, and/or nohost
     --sd-id <id>         rfc5424 structured data ID
     --sd-param <data>    rfc5424 structured data name=value
     --msgid <msgid>      set rfc5424 message id field
 -u, --socket <socket>    write to this Unix socket
     --socket-errors[=<on|off|auto>]
                          print connection errors when using Unix sockets
     --journald[=<file>]  write journald entry
"
	local stderr="--stderr" no_act logger_options
	for ((;$#;)) ; do
		case "$1" in
			-q|--quiet) unset stderr ;;
			-Q|--no-act) no_act="--no-act" ;;
			-e|--skip-empty|--octet-count|--prio-prefix|-T|--tcp|-d|--udp|--rfc3164)
				logger_options+=("$1") ;;
			-f|--file|-S|--size|-n|--server|-P|--port|--sd-id|--sd-param|--msgid|-u|--socket)
				logger_options+=("$1")
				shift
				logger_options+=("$1") ;;
			--rfc5424*|--socket-errors*|--journald*)
				logger_options+=("$1") ;;
			-h|--help) echo "$helpmsg" ; return ;;
			-V|--version) echo "$FUNCNAME $PGPI_VERSION" ; return ;;
			--) shift ; break ;;
			-*) echo -e "$FUNCNAME: Error: Unrecognized option/parameters $1\n$helpmsg" >&2 ; return 2 ;;
			*) break ;;
		esac
		shift
	done

	local priority=$1
	shift
	if ((loglevels[$priority] > $LOGLEVEL)) ; then
		# If there is no MESSAGE, purge stdin; else do nothing.
		[[ "$@" ]] || cat >/dev/null
	else
		logger -p "$priority" $stderr $no_act "${logger_options[@]}" --id=$$ --tag "${0##*/}" -- "$@"
	fi
	((loglevels[$priority] > loglevels[$LOGEXITPRIO] )) || exit $((8+loglevels[$priority]))
}

mrz_checkdigit() {
	local helpmsg="Usage: $FUNCNAME STRING [EXPECTED_RESULT]
If there is no second arg: output calculated check digit from [0-9A-Z<]* string
else return non-zero if EXPECTED_RESULT differs from calculated check digit.
"
	for ((;$#;)) ; do
		case "$1" in
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $PGPI_VERSION" ; return ;;
			--) shift ; break ;;
			-*) echo -e "$FUNCNAME: Error: Unrecognized option/parameters $1\n$helpmsg" >&2 ; return 2 ;;
			*) break ;;
		esac
	done

	local char sum=0 weight=(7 3 1)
	for ((i=0;i<${#1};i++)) ; do
		char=${1:$i:1}
		case $char in
			[0-9]) ((sum+=char*${weight[$((i%3))]})) ;;
			[A-Z]) ((sum+=($(printf "%d" "'$char'")-55)*${weight[$((i%3))]})) ;;
		esac
	done

	if ! [[ "$2" ]] ; then
		echo $((sum%10))
	else
		[[ "$2" == $((sum%10)) ]]
		return $?
	fi
}

mrz_analyse() {
	local helpmsg="Usage: $FUNCNAME MRZ
Analyse a Machine Readable Zone and output content of an associative array"

	for ((;$#;)) ; do
		case "$1" in
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $PGPI_VERSION" ; return ;;
			--) shift ; break ;;
			-*) echo -e "$FUNCNAME: Error: Unrecognized option/parameters $1\n$helpmsg" >&2 ; return 2 ;;
			*) break ;;
		esac
	done

	local ch mrz=("$@")
	local -A doc

	$PGPI_LOGCMD debug "mrz[0]= \"${mrz[0]}\""
	if [[ ${mrz[0]:0:1} != P ]] ; then
		$PGPI_LOGCMD debug "mrz[0]= \"${mrz[0]}\""
		$PGPI_LOGCMD warning "$FUNCNAME: unsupported. (not an ISO/IEC 7501-1 passport)"
		return 1
	fi
	$PGPI_LOGCMD debug "mrz[1]= \"${mrz[1]}\""
	if [[ ${#mrz[0]} != 44 ]] || [[ ${#mrz[1]} != 44 ]] ; then
		$PGPI_LOGCMD warning "$FUNCNAME: Invalid MRZ lenght ${#mrz[0]} ${#mrz[1]}"
		return 2
	fi

	doc=(
		[type]=${mrz[0]:0:2}
		[country]=${mrz[0]:2:3}
		[all_names]=${mrz[0]:5}
		[number]=${mrz[1]:0:9}
		[check_number]=${mrz[1]:9:1}
		[nationality]=${mrz[1]:10:3}
		[date_of_birth]=${mrz[1]:13:6}
		[check_date_of_birth]=${mrz[1]:19:1}
		[sex]=${mrz[1]:20:1}
		[expiration_date]=${mrz[1]:21:6}
		[check_expiration_date]=${mrz[1]:27:1}
		[personal_number]=${mrz[1]:28:14}
		[check_personal_number]=${mrz[1]:42:1}
		[composite]="${mrz[1]:0:10}${mrz[1]:13:7}${mrz[1]:21:20}"
		[check_composite]=${mrz[1]:43:1}
	)

	for ch in number date_of_birth expiration_date personal_number composite ; do
		doc[checked_$ch]=$(mrz_checkdigit "${doc[$ch]}")
		doc[valid_$ch]=$( [[ ${doc[checked_$ch]} == ${doc[check_$ch]} ]] && echo true || echo false )
		${doc[valid_$ch]} || $PGPI_LOGCMD warning "OBI WAN KENOBI ??? $ch checksum -> ${doc[check_$ch]}. Should be ${doc[checked_$ch]}."
	done

	doc[names]=$(echo $(echo "${doc[all_names]#*<<}" | tr '<' ' ') )
	doc[surname]=$(echo $(echo "${doc[all_names]%%<<*}" | tr '<' ' ') )
	declare -p doc | sed 's,^[^=]*=,,'
}

pgpi_gen_udid4() {
	local mrzn sname gname c iso cname tohash1 tohash2
	local helpmsg="Usage: $FUNCNAME PARAMETERS...
Parameters:
    -s, --surname SURNAME            Surname/family name at birth
    -g, --given-names GIVEN_NAME     Given names at birth
    -d, --birth-date BIRTH_DATE      birth date
    -p, --birth-place PLACE          coordinate of birth place
    -m, --mrz-names NAMES_IN_MRZ     SURNAME<<GIVEN<NAMES< as written in a Machine Readable Zone
    -c, --birth-country COUNTRY_CODE country code of birth place
"
	for ((;$#;)) ; do
	case "$1" in
		-h|--h*) echo "$helpmsg" ; return ;;
		-V|--vers*) echo "$FUNCNAME $PGPI_VERSION" ; return ;;
		-m|--mrz-n*)
			shift
			mrzn=$1 ;;
		-s|--s*)
			shift
			sname=$(sed 's,[ ;,<-]\+,<,g'<<<"$1" )
			sname="${sname^^}"
			if ! [[ "$sname" =~ ^[A-Z'<']+$ ]] ; then
				$PGPI_LOGCMD err "$FUNCNAME: only [A-Z] characters allowed in $1"
				return 1
			fi ;;
		-g|--g*)
			shift
			gname=$(sed 's,[ ;,<-]\+,<,g'<<<"$1" )
			gname="${gname^^}<<"
			if ! [[ "$gname" =~ ^[A-Z'<']+$ ]] ; then
				$PGPI_LOGCMD err "$FUNCNAME: only [A-Z] characters allowed in $1"
				return 1
			fi ;;
		-d|--birth-d*)
			shift
			if ((${#1}<8)) ; then
				bdate="$(($(date +"%y%m%d") < $1 ? 19 : 20))$1"
				$PGPI_LOGCMD notice "$FUNCNAME: birth date '$1' is too short, assuming $bdate."
			else
				bdate=$1
			fi
			if ! tohash2=$(date --date "$bdate" +"%Y-%m-%d" ) ; then
				$PGPI_LOGCMD err "$FUNCNAME: can't reformart birthdate $date"
				return 2
			fi ;;
		-c|--birth-c*)
			shift
			if ! read c iso cname < <(grep "	$1	" "$GEOLIST_CENTROID") ; then
				$PGPI_LOGCMD err "$FUNCNAME: no \"$1\" in $GEOLIST_CENTROID"
				return 3
			fi
			$PGPI_LOGCMD debug "$FUNCNAME: $c $iso $cname" ;;
		-p|--birth-p*)
			shift
			#TODO: check if coordinate is valid (cf. Specifications)
			c="$1" ;;
		*) echo -e "$FUNCNAME: Error: Unrecognized option/parameters $1\n$helpmsg" >&2 ; return 2 ;;
	esac
	shift
	done
	[[ "$mrzn" ]] || mrzn="${sname}<<$gname"
	if ! tohash1=$(grep -o "[A-Z]\{1,32\}<<[A-Z]\{1,32\}<[A-Z]\{0,32\}<" <<<"$mrzn" ) ; then
		$PGPI_LOGCMD err "$FUNCNAME: no complete surname and given names extracted from $mrzn"
		return 1
	fi
	$PGPI_LOGCMD debug "$FUNCNAME: names: $tohash1"
	$PGPI_LOGCMD debug "$FUNCNAME: birthdate: $tohash2"
	echo "$(printf "$tohash1$tohash2" | md5sum | xxd -r -p | basenc --base64url | sed 's/==$//')$c"
}

pgpi_str_to_json() {
	local helpmsg="Usage: $FUNCNAME [STRING]...
"'Escape "\" and [/"\b\f\n\r\t] characters as required by JSON format.
If there is no STRING in command line, read it from stdin.
'

	for ((;$#;)) ; do
		case "$1" in
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $PGPI_VERSION" ; return ;;
			--) shift ; break ;;
			-*) echo -e "$FUNCNAME: Error: Unrecognized option/parameters $1\n$helpmsg" >&2 ; return 2 ;;
			*) break ;;
		esac
	done

	local from='cat'
	[[ "$@" ]] && from='eval echo "$@"'
	$from | sed 's,\\,\\\\,g; s,/,\\/,g; s,",\\",g; s,\x08,\\b,g; s,\x0c,\\f,g; s,\r,\\r,g; s,\t,\\t,g;' | sed ':a;N;$!ba; s,\n,\\n,g;'
}

pgpi_var_to_json() {
	local nested=false shft=0
	local helpmsg="Usage: $FUNCNAME [OPTIONS] VARNAME
Output content of VARNAME in a JSON format.

Options:
    -n, --nested        Assume any value beginning with \"declare -[aA]\" are nested data to be translate to JSON format
    -s, --shift NUMBER  Number of tabs shifting of each line (default $shft)
"
	for ((;$#;)) ; do
		case "$1" in
			-n|--nest*) nested=true ;;
			-s|--shift) shift ; shft=$(($1)) ;;
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $PGPI_VERSION" ; return ;;
			--) shift ; break ;;
			-*) echo -e "$FUNCNAME: Error: Unrecognized option/parameters $1\n$helpmsg" >&2 ; return 2 ;;
			*) break ;;
		esac
		shift
	done

	local lb notstarted=true
	local -n aa=$1
	((shft)) && lb=$(eval printf '\\t%.0s' {1..$shft})
	printf "$lb{\n"
	for i in "${!aa[@]}"; do
		$notstarted || printf ",\n"
		notstarted=false
		#TODO: Maybe use and depend on "jq". cf. https://stackoverflow.com/questions/44792241/constructing-a-json-hash-from-a-bash-associative-array
		if $nested && [[ "${aa[$i]}" =~ ^declare" "-[Aa][a-zA-Z]*" "([a-zA-Z_][a-zA-Z0-9_]*)= ]] ; then
			echo
			echo -n "$lb	\"$(pgpi_str_to_json "$i")\": $(pgpi_var_to_json --nested --shift $((shft+2)) "${BASH_REMATCH[1]}")"
		else
			echo -n "$lb	\"$(pgpi_str_to_json "$i")\": \"$(pgpi_str_to_json "${aa[$i]}")\""
		fi
	done
	printf "\n$lb}\n"
}



_chooseinlist() {
# Argument 1: Prompt before the list
# Argument 2(optionnal): if argument 2 is a number>0, it indicates the number of item by line - defaut: 3.
# Arguments 2,3...n : items to choose
# Return the number of the choosen item, 0 if no items.

	local ret=0 nperline=3 n
	echo -n "$1"
	shift
	(($1>0)) && nperline=$1 && shift
	n=$#
	for ((i=0;$#;)) ; do
		if ((i%nperline)) ; then
			echo -en "\t\t"
		else
			echo -en "\n\t"
		fi
		echo -en "$((++i))) $1"
		shift
	done
	echo
	while ! ((ret)) || ((ret<1 || ret>n)) ; do
		read -p "Reply (1-$n) ? " ret
	done
	return $ret
}

# Do nothing else if sourced
[[ "$BASH_SOURCE" == "$0" ]] || return 0


### Init ###

#_onexit() {
#	[[ -d "$TMPDIR" ]] && rm -rvf "$TMPDIR" | $PGPI_LOGCMD info
#}
#
#TMPDIR=$(mktemp -d -t "$PGPI_NAME".XXXXXX) || log crit "crit: Can not create a safe temporary directory."
#
#trap _onexit EXIT

[[ "$1" ]] || { echo -e "$usage" >&2 ; exit 1 ; }
#scanimage -l 2 -t 2 -x 120 -y 170 --mode Color --resolution 200 --format=tiff > tmpimg.tiff


### Run ###

while [[ "$1" ]] ; do
	f="$1"
	shift


	facep=$(facedetect --best -- "$f" 2> >($PGPI_LOGCMD notice) || true )
	if ! [[ "$facep" ]] ; then
		$PGPI_LOGCMD err "Error: No face detected in $f"
		continue
	fi
	read px py sx sy etc <<<"$facep"
	mx=$((sx*$FACE_MARGIN_WIDTH))
	my=$((sy*$FACE_MARGIN_HEIGHT))
	$PGPI_LOGCMD info "$f face -> position: +$px+$py  size: ${sx}x$sy  marges: +${mx}+$my"


	if ! mrz=($(gm convert -crop +0+$((py+sy+my)) "$f" - 2> >($PGPI_LOGCMD notice) | tesseract --tessdata-dir "$TESSDATADIR" -l mrz - - 2> >($PGPI_LOGCMD notice) | sed 's/[^0-9A-Z<]*//g' | grep -m1 -A2 "<<")) ; then
		$PGPI_LOGCMD err "$f: No machine-readable zone detected"
		continue
	fi

	unset DOCUMENT
	if ! declare -A DOCUMENT=$(mrz_analyse "${mrz[@]}") ; then
		$PGPI_LOGCMD err "$f: Invalid or unsupported machine-readable zone"
		continue
	fi

	DOCUMENT[filename]=$f
	DOCUMENT[face_scan_64url]=$(gm convert -crop $((sx+mx))x$((sy+my))+$((px-(mx/2)))+$((py-(my/2))) "$f" jpeg:- 2> >($PGPI_LOGCMD warning) | basenc --base64url --wrap 0 )
	if ((${#DOCUMENT[face_scan_64url]} < 2048 )) ; then
		$PGPI_LOGCMD warning "$outdir/face.jpg: too small (${#DOCUMENT[face_scan_64url]} < 2048)"
		unset DOCUMENT[face_scan_64url]
	elif ((${#DOCUMENT[face_scan_64url]} > (1<<16) )) ; then
		$PGPI_LOGCMD warning "$outdir/face.jpg: too big (${#DOCUMENT[face_scan_64url]} > $((1<<16)))"
		unset DOCUMENT[face_scan_64url]
	fi

	#WARNING: mrz data may be irrelevant to generate udid4. eg:
	#         * Surname or given names may be incomplete (cut bc exceed mrz size)
	#         * Surname or given names may differs from those given at birth (marriage, gender change, etc.)
	#         * Surname or given names transliteration may have change over time
	#         * Year of birth date is not written with 4 digit (and people may live longer than 100 years)
	#         * Humans may have done error on birth date, surname or given names.
	if ! DOCUMENT[udid4_auto]=$(pgpi_gen_udid4 --mrz-names "${DOCUMENT[all_names]}" --birth-date "${DOCUMENT[date_of_birth]}" --birth-country "${DOCUMENT[nationality]}") ; then
		$PGPI_LOGCMD warning "can't generate an udid4 from mrz data"
		unset DOCUMENT[udid4_auto]
	fi

	if $PGPI_INTERACTIVE ; then
		date_of_birth=$(date --date "$(($(date +"%y%m%d") < ${DOCUMENT[date_of_birth]} ? 19 : 20))${DOCUMENT[date_of_birth]}" +"%Y-%m-%d")
		while true ; do
			echo "
Surname: ${surname:=${DOCUMENT[surname]}}
Given names: ${names:=${DOCUMENT[names]}}
Date of birth: ${date_of_birth}
Country of birth: ${country_of_birth:=${DOCUMENT[nationality]}}
" >&2
			read -p " Is that correct (y/n) ? " rep
			case "$rep" in
			  [yY]*)
				break ;;
			  [nN]*)
				read -p "Surname [${surname:=${DOCUMENT[surname]}}] ? "
				surname=${REPLY:-$surname}
				read -p "Names [${names:=${DOCUMENT[names]}}] ? "
				names=${REPLY:-$names}
				read -p "Date of birth [${date_of_birth:=${DOCUMENT[date_of_birth]}}] ? "
				date_of_birth=${REPLY:-$date_of_birth}
				read -p "Surname [${country_of_birth:=${DOCUMENT[nationality]}}] ? "
				country_of_birth=${REPLY:-$country_of_birth}
				continue ;;
			  *) echo "  please answer \"yes\" or \"no\"" >&2 ;;
			esac
		done
		if ! DOCUMENT[udid4]=$(pgpi_gen_udid4 --surname "$surname" --given-names "$names" --birth-date "$date_of_birth" --birth-country "$country_of_birth") ; then
			$PGPI_LOGCMD error "can't generate an udid4 from data you have validated"
			unset DOCUMENT[udid4]
		fi
	fi

	if $PGPI_OUTPUTJSON ; then
		pgpi_var_to_json DOCUMENT
		continue
	fi

	#for i in "${!DOCUMENT[@]}"; do printf "[$i] -> ${DOCUMENT[$i]}\n"; done | $PGPI_LOGCMD debug

	outdir="$PGPI_OUTPATH/${mrz[0]//</_}"
	mkdir -p "$outdir"

	cp -bvf "$f" "$outdir/document.orig" 2> >($PGPI_LOGCMD warning) | $PGPI_LOGCMD info
	pgpi_var_to_json DOCUMENT > "$outdir/document.json" 2> >($PGPI_LOGCMD crit)
done

exit 0
