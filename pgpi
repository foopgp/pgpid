#!/bin/bash
#
# Copyright © 2021 by Friends Of OpenPGP organization.
#          Confidential - All Right Reserved
#
# Extract MRZ data and photo from ID documents (eg: International Passeports)
# to generate OpenPGP certificates and keys to be imported for multiple applications (mail, chat, vote, etc.).
# May also move or copy 3 importante keys (SC, E and A) to OpenPGP Security hardware (nitrokeys, yubikeys, etc.)
#

if [[ "$1" == --bash-completion ]] ; then
	_pgpi_completion()
	{
		local cur prev options
		local IFS=$'\n'

		COMPREPLY=()
		cur=${COMP_WORDS[COMP_CWORD]}

		if [[ "$cur" == -* ]]; then
			options="--output-path --verbose --quiet --help --version"

			COMPREPLY=( $(IFS=" " compgen -W "$options" -- $cur ) )
		else
			prev=${COMP_WORDS[COMP_CWORD-1]}
			case $prev in
				-o|--output-path)
					COMPREPLY=( $(compgen  -d -- $cur ) )
					return ;;
				# some options will exit without executing any actions, so don't complete anything
				-h|--help|-V|--version)
					return ;;
			esac

			COMPREPLY=( $(compgen -o plusdirs -f -X '!*.@(gif|GIF|jp?(e)g|JP?(E)G|miff|tif?(f)|pn[gm]|PN[GM]|p[bgp]m|bmp|BMP|xpm|ico|xwd|tga|pcx)' -- $cur ) )
		fi
	}
	complete -o filenames -F _pgpi_completion "$BASH_SOURCE"
	return 0
fi

PGPI_NAME="$(basename $(readlink -f "$BASH_SOURCE") )"
PGPI_VERSION="0.0.1"


### Constants ###

FACE_MARGIN_WIDTH="25/100"
FACE_MARGIN_HEIGHT="50/100"
TESSDATADIR="$(dirname "$0")/data/"
GEOLIST_CENTROID="$(dirname "$0")/data/geolist_centroid.txt"

### Default option values ###

if [[ "$BASH_SOURCE" == "$0" ]] ; then
	# run as a program
	set -e
	# set global constants real constant (read only)
	declare -r FACE_MARGIN_WIDTH FACE_MARGIN_HEIGHT TESSDATADIR GEOLIST_CENTROID
	_exit="exit"
	LOGEXITPRIO=crit
	LOGLEVEL=5

	PGPI_OUTPATH="$PWD"

	usage="Usage: $BASH_SOURCE [OPTIONS]... [--] IMAGES...
If $PGPI_NAME succeed, it will create a subdirectories containing all generated files."

	soptions="
    -o, --output-path PATH   emplacement for generated subdirs and files (current: $PGPI_OUTPATH )
    -v, --verbose            increase log verbosity: ...<notice[5]<info[6]<debug[7]  (current: $LOGLEVEL)
    -q, --quiet              decrease log verbosity: ...<err[3]<warning[4]<notice[5]<...  (current: $LOGLEVEL)
    -h, --help               show this help and exit
    -V, --version            show version and exit"
else
	# run as a library (source $0)
	_exit="true"
	LOGEXITPRIO=emerg
	LOGLEVEL=6

	usage="Usage: source $BASH_SOURCE [OPTIONS]..."

	soptions="
        --bash-completion    set completion for $BASH_SOURCE program and return (without loading anything else)
    -l, --log-level LEVEL    log level: emerg<1=alert<crit<3=err<warning<5=notice<info<7=debug (current: $LOGLEVEL)
    -h, --help               show this help
    -V, --version            show version"
fi

### Handling options ###

helpmsg="$usage

Options:
    -L, --log-exit PRIORITY  log exit priority: emerg|alert|crit|err|warning|... (current: $LOGEXITPRIO )
$soptions
"

for ((i=0;$#;)) ; do
case "$1" in
	-o|--output*) shift ; PGPI_OUTPATH="$1" ; ( cd "$PGPI_OUTPATH" && touch . ) ;;
	-l|--log-l*) shift ; LOGLEVEL="$1" ; [[ "$LOGLEVEL" == [0-9] ]] || { echo -e "Error: log-level out of range [0-7]" >&2 ; $_exit 2 ; } ;;
	-L|--log-e*) shift ; LOGEXITPRIO="$1"
		grep -q "\<$LOGEXITPRIO\>" <<<${!loglevels[@]} || { echo -e "Error: log-exit \"$LOGEXITPRIO\" is none of: ${!loglevels[@]}" >&2 ; $_exit 2 ; } ;;
	-v|--verb*) ((LOGLEVEL++)) ;;
	-q|--quiet) ((LOGLEVEL--)) ;;
	-h|--h*) echo "$helpmsg" ; $_exit ;;
	-V|--vers*) echo "$PGPI_NAME $PGPI_VERSION" ; $_exit ;;
	--) shift ; break ;;
	-*) echo -e "Error: Unrecognized option $1\n$helpmsg" >&2 ; $_exit 2 ;;
	*) break ;;
esac
shift
done


### functions ###

. pl-log --no-act --log-level "$LOGLEVEL" --log-exit "$LOGEXITPRIO"

mrz_checkdigit() {
	local helpmsg="Usage: $FUNCNAME STRING [EXPECTED_RESULT]
If there is no second arg: output calculated check digit from [0-9A-Z<]* string
else return non-zero if EXPECTED_RESULT differs from calculated check digit.
"
	for ((;$#;)) ; do
		case "$1" in
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $PGPI_VERSION" ; return ;;
			--) shift ; break ;;
			-*) echo -e "$FUNCNAME: Error: Unrecognized option/parameters $1\n$helpmsg" >&2 ; return 2 ;;
			*) break ;;
		esac
	done

	local char sum=0 weight=(7 3 1)
	for ((i=0;i<${#1};i++)) ; do
		char=${1:$i:1}
		case $char in
			[0-9]) ((sum+=char*${weight[$((i%3))]})) ;;
			[A-Z]) ((sum+=($(printf "%d" "'$char'")-55)*${weight[$((i%3))]})) ;;
		esac
	done

	if ! [[ "$2" ]] ; then
		echo $((sum%10))
	else
		[[ "$2" == $((sum%10)) ]]
		return $?
	fi
}

mrz_analyse() {
	local helpmsg="Usage: $FUNCNAME AANAME MRZ
Analyse a Machine Readable Zone and fill the associative array named AANAME"

	for ((;$#;)) ; do
		case "$1" in
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $PGPI_VERSION" ; return ;;
			--) shift ; break ;;
			-*) echo -e "$FUNCNAME: Error: Unrecognized option/parameters $1\n$helpmsg" >&2 ; return 2 ;;
			*) break ;;
		esac
	done

	local -n doc=$1
	shift
	local ch mrz=("$@")

	pl_log debug "mrz[0]= \"${mrz[0]}\""
	if [[ ${mrz[0]:0:1} != P ]] ; then
		pl_log debug "mrz[0]= \"${mrz[0]}\""
		pl_log warning "$FUNCNAME: unsupported. (not an ISO/IEC 7501-1 passport)"
		return 1
	fi
	pl_log debug "mrz[1]= \"${mrz[1]}\""
	if [[ ${#mrz[0]} != 44 ]] || [[ ${#mrz[1]} != 44 ]] ; then
		pl_log warning "$FUNCNAME: Invalid MRZ lenght ${#mrz[0]} ${#mrz[1]}"
		return 2
	fi

	doc=(
		[type]=${mrz[0]:0:2}
		[country]=${mrz[0]:2:3}
		[all_names]=${mrz[0]:5}
		[number]=${mrz[1]:0:9}
		[check_number]=${mrz[1]:9:1}
		[nationality]=${mrz[1]:10:3}
		[date_of_birth]=${mrz[1]:13:6}
		[check_date_of_birth]=${mrz[1]:19:1}
		[sex]=${mrz[1]:20:1}
		[expiration_date]=${mrz[1]:21:6}
		[check_expiration_date]=${mrz[1]:27:1}
		[personal_number]=${mrz[1]:28:14}
		[check_personal_number]=${mrz[1]:42:1}
		[composite]="${mrz[1]:0:10}${mrz[1]:13:7}${mrz[1]:21:20}"
		[check_composite]=${mrz[1]:43:1}
	)

	for ch in number date_of_birth expiration_date personal_number composite ; do
		doc[checked_$ch]=$(mrz_checkdigit "${doc[$ch]}")
		doc[valid_$ch]=$( [[ ${doc[checked_$ch]} == ${doc[check_$ch]} ]] && echo true || echo false )
		${doc[valid_$ch]} || pl_log warning "OBI WAN KENOBI ??? $ch checksum -> ${doc[check_$ch]}. Should be ${doc[checked_$ch]}."
	done

	doc[names]=$(echo $(echo "${doc[all_names]#*<<}" | tr '<' ' ') )
	doc[surname]=$(echo $(echo "${doc[all_names]%%<<*}" | tr '<' ' ') )
}

pgpi_gen_udid4() {
	local mrzn sname gname c iso cname tohash1 tohash2
	local helpmsg="Usage: $FUNCNAME PARAMETERS...
Parameters:
    -s, --surname SURNAME            Surname/family name at birth
    -g, --given-names GIVEN_NAME     Given names at birth
    -d, --birth-date BIRTH_DATE      birth date
    -p, --birth-place PLACE          coordinate of birth place
    -m, --mrz-names NAMES_IN_MRZ     SURNAME<<GIVEN<NAMES< as written in a Machine Readable Zone
    -c, --birth-country COUNTRY_CODE country code of birth place
"
	for ((;$#;)) ; do
	case "$1" in
		-h|--h*) echo "$helpmsg" ; return ;;
		-V|--vers*) echo "$FUNCNAME $PGPI_VERSION" ; return ;;
		-m|--mrz-n*)
			shift
			mrzn=$1 ;;
		-s|--s*)
			shift
			sname=$(sed 's,[ ;,<-]\+,<,g'<<<"$1" )
			sname="${sname^^}"
			if ! (LANG= ; [[ "$sname" =~ ^[A-Z\<]+$ ]]) ; then
				pl_log error "$FUNCNAME: only [A-Z] characters allowed in $1"
				return 1
			fi ;;
		-g|--g*)
			shift
			gname=$(sed 's,[ ;,<-]\+,<,g'<<<"$1" )
			gname="${gname^^}<<"
			if ! (LANG= ; [[ "$gname" =~ ^[A-Z\<]+$ ]]) ; then
				pl_log error "$FUNCNAME: only [A-Z] characters allowed in $1"
				return 1
			fi ;;
		-d|--birth-d*)
			shift
			bdate=$1
			if ((${#1}<8)) ; then
				bdate="$(($(date +"%y%m%d") < bdate ? 19 : 20))$bdate"
				pl_log notice "$FUNCNAME: birth date '$1' is too short, assuming $bdate."
			fi
			if ! tohash2=$(date --date "$bdate" +"%Y-%m-%d" ) ; then
				pl_log error "$FUNCNAME: can't reformart birthdate $date"
				return 2
			fi ;;
		-c|--birth-c*)
			shift
			if ! read c iso cname < <(grep "	$1	" "$GEOLIST_CENTROID") ; then
				pl_log error "$FUNCNAME: no \"$1\" in $GEOLIST_CENTROID"
				return 3
			fi
			pl_log debug "$FUNCNAME: $c $iso $cname" ;;
		-p|--birth-p*)
			shift
			#TODO: check if coordinate is valid (cf. Specifications)
			c="$1" ;;
		*) echo -e "$FUNCNAME: Error: Unrecognized option/parameters $1\n$helpmsg" >&2 ; return 2 ;;
	esac
	shift
	done
	[[ "$mrzn" ]] || mrzn="${sname}<<$gname"
	if ! tohash1=$(grep -o "[A-Z]\{1,32\}<<[A-Z]\{1,32\}<[A-Z]\{0,32\}<" <<<"$mrzn" ) ; then
		pl_log error "$FUNCNAME: no complete surname and given names extracted from $mrzn"
		return 1
	fi
	pl_log debug "$FUNCNAME: names: $tohash1"
	pl_log debug "$FUNCNAME: birthdate: $tohash2"
	echo "$(printf "$tohash1$tohash2" | md5sum | xxd -r -p | basenc --base64url | sed 's/==$//')$c"
}

pgpi_json_from_str() {
	local helpmsg="Usage: $FUNCNAME [STRING]...
"'Escape "\" and [/"\b\f\n\r\t] characters as required by JSON format.
If there is no STRING in command line, read it from stdin.
'

	for ((;$#;)) ; do
		case "$1" in
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $PGPI_VERSION" ; return ;;
			--) shift ; break ;;
			-*) echo -e "$FUNCNAME: Error: Unrecognized option/parameters $1\n$helpmsg" >&2 ; return 2 ;;
			*) break ;;
		esac
	done

	local from='cat'
	[[ "$@" ]] && from='eval echo "$@"'
	$from | sed 's,\\,\\\\,g; s,/,\\/,g; s,",\\",g; s,\x08,\\b,g; s,\x0c,\\f,g; s,\r,\\r,g; s,\t,\\t,g;' | sed ':a;N;$!ba; s,\n,\\n,g;'
}

pgpi_json_from_var() {
	local nested=false shft=0
	local helpmsg="Usage: $FUNCNAME [OPTIONS] VARNAME
Output content of VARNAME in a JSON format.

Options:
    -n, --nested        Assume any value beginning with \"declare -[aA]\" are nested data to be translate to JSON format
    -s, --shift NUMBER  Number of tabs shifting of each line (default $shft)
"
	for ((;$#;)) ; do
		case "$1" in
			-n|--nest*) nested=true ;;
			-s|--shift) shift ; shft=$(($1)) ;;
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $PGPI_VERSION" ; return ;;
			--) shift ; break ;;
			-*) echo -e "$FUNCNAME: Error: Unrecognized option/parameters $1\n$helpmsg" >&2 ; return 2 ;;
			*) break ;;
		esac
		shift
	done

	local lb notstarted=true
	local -n aa=$1
	((shft)) && lb=$(eval printf '\\t%.0s' {1..$shft})
	printf "$lb{\n"
	for i in "${!aa[@]}"; do
		$notstarted || printf ",\n"
		notstarted=false
		#TODO: Maybe use and depend on "jq". cf. https://stackoverflow.com/questions/44792241/constructing-a-json-hash-from-a-bash-associative-array
		if $nested && [[ "${aa[$i]}" =~ ^declare" "-[Aa][a-zA-Z]*" "([a-zA-Z_][a-zA-Z0-9_]*)= ]] ; then
			#echo
			echo -n "$lb	\"$(pgpi_json_from_str -- "$i")\":"$'\n'"$(pgpi_json_from_var --nested --shift $((shft+2)) "${BASH_REMATCH[1]}")"
		else
			echo -n "$lb	\"$(pgpi_json_from_str -- "$i")\": \"$(pgpi_json_from_str -- "${aa[$i]}")\""
		fi
	done
	printf "\n$lb}\n"
}

_yesno() {
	local usage="Usage: $FUNCNAME [OPTIONS] QUESTION"
	local helpmsg="
If REPLY == 'yes', return 0
If REPLY == 'no', return 1
Else loop asking the question.

Options:
      --default=<yes|no>   Set a default answer
  -p, --preamble TEXT      Text to display before the question
"
	local def pr question
	for ((;$#;)) ; do
		case "$1" in
			--default=yes) def="yes" ;;
			--default=no) def="no" ;;
			-p|--pre*) shift ; pr="$1" ;;
			-h|--h*) printf "%s\n%s\n" "$usage" "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $PGPI_VERSION" ; return ;;
			--) shift ; break ;;
			-*) printf "$FUNCNAME: Error: unrecognized option '%s'\nTry '$FUNCNAME --help' for more information.\n" "$1" >&2 ; return 2 ;;
			*) break ;;
		esac
		shift
	done
	question=" $1 (y/n)"
	[[ -z "$def" ]] || question+=" [$def]"

	while true ; do
		echo "$pr" >&2
		read -p " $question ? " rep
		rep=${rep:-$def}
		case "${rep,,}" in
		  y|yes|oui|'sí'|ja|si|'да')
			return 0 ;;
		  n|no|non|nein|'нет')
			return 1 ;;
		  *) echo "  please answer \"yes\" or \"no\"" >&2 ;;
		esac
	done
}


_chooseinlist() {
# Argument 1: Prompt before the list
# Argument 2(optionnal): if argument 2 is a number>0, it indicates the number of item by line - defaut: 3.
# Arguments 2,3...n : items to choose
# Return the number of the choosen item, 0 if no items.

	local ret=0 nperline=3 n
	echo -n "$1"
	shift
	(($1>0)) && nperline=$1 && shift
	n=$#
	for ((i=0;$#;)) ; do
		if ((i%nperline)) ; then
			echo -en "\t\t"
		else
			echo -en "\n\t"
		fi
		echo -en "$((++i))) $1"
		shift
	done
	echo
	while ! ((ret)) || ((ret<1 || ret>n)) ; do
		read -p "Reply (1-$n) ? " ret
	done
	return $ret
}


# Do nothing else if sourced
[[ "$BASH_SOURCE" == "$0" ]] || return 0


### Init ###

#_onexit() {
#	[[ -d "$TMPDIR" ]] && rm -rvf "$TMPDIR" | pl_log info
#}
#
#TMPDIR=$(mktemp -d -t "$PGPI_NAME".XXXXXX) || log crit "crit: Can not create a safe temporary directory."
#
#trap _onexit EXIT

[[ "$1" ]] || { echo -e "$usage" >&2 ; exit 1 ; }
#scanimage -l 2 -t 2 -x 120 -y 170 --mode Color --resolution 200 --format=tiff > tmpimg.tiff


### Run ###

while [[ "$1" ]] ; do
	f="$1"
	shift

	facep=$(facedetect --best -- "$f" 2> >(pl_log notice) || true )
	if ! [[ "$facep" ]] ; then
		pl_log error "Error: No face detected in $f"
		continue
	fi
	read px py sx sy etc <<<"$facep"
	mx=$((sx*$FACE_MARGIN_WIDTH))
	my=$((sy*$FACE_MARGIN_HEIGHT))
	pl_log info "$f face -> position: +$px+$py  size: ${sx}x$sy  marges: +${mx}+$my"

	declare -A DOCUMENT=()
	if mrz=($(gm convert -crop +0+$((py+sy+my)) "$f" - 2> >(pl_log notice) | tesseract --tessdata-dir "$TESSDATADIR" -l mrz - - 2> >(pl_log notice) | sed 's/[^0-9A-Z<]*//g' | grep -m1 -A2 "<<")) ; then
		if mrz_analyse DOCUMENT "${mrz[@]}" ; then
			#WARNING: mrz data may be irrelevant to generate udid4. eg:
			#         * Surname or given names may be incomplete (cut bc exceed mrz size)
			#         * Surname or given names may differs from those given at birth (marriage, gender change, etc.)
			#         * Surname or given names transliteration may have change over time
			#         * Year of birth date is not written with 4 digit (and people may live longer than 100 years)
			#         * Humans may have done error on birth date, surname or given names.
			if ! DOCUMENT[udid4_auto]=$(pgpi_gen_udid4 --mrz-names "${DOCUMENT[all_names]}" --birth-date "${DOCUMENT[date_of_birth]}" --birth-country "${DOCUMENT[nationality]}") ; then
				pl_log warning "can't generate an udid4 from mrz data"
				unset DOCUMENT[udid4_auto]
			fi
		else
			pl_log warning "$f: Invalid or unsupported machine-readable zone"
		fi
	else
		pl_log warning "$f: No machine-readable zone detected"
	fi

	DOCUMENT[filename]=$f
	DOCUMENT[face_scan_64url]=$(gm convert -crop $((sx+mx))x$((sy+my))+$((px-(mx/2)))+$((py-(my/2))) "$f" jpeg:- 2> >(pl_log warning) | basenc --base64url )
	if ((${#DOCUMENT[face_scan_64url]} < 2048 )) ; then
		pl_log error "$outdir/face.jpg: too small (${#DOCUMENT[face_scan_64url]} < 2048)"
		continue
	elif ((${#DOCUMENT[face_scan_64url]} > (1<<16) )) ; then
		pl_log error "$outdir/face.jpg: too big (${#DOCUMENT[face_scan_64url]} > $((1<<16)))"
		continue
	fi

	declare -A PGPID=()

	PGPID[document1]="$(declare -p DOCUMENT)"

	PGPID[birth_date]=$(date --date "$(($(date +"%y%m%d") < DOCUMENT[date_of_birth] ? 19 : 20))${DOCUMENT[date_of_birth]}" +"%Y-%m-%d")
	while true ; do
		echo "
Surname at birth: ${PGPID[birth_surname]:=${DOCUMENT[surname]}}
Given names at birth: ${PGPID[birth_names]:=${DOCUMENT[names]}}
Date of birth: ${PGPID[birth_date]}
Country of birth: ${PGPID[birth_country]:=${DOCUMENT[nationality]}}
" >&2
		! _yesno "Is that correct" || break

		read -p "Birth surname [${PGPID[birth_surname]}] ? "
		PGPID[birth_surname]=${REPLY:-${PGPID[birth_surname]}}
		read -p "Birth names [${PGPID[birth_names]}] ? "
		PGPID[birth_names]=${REPLY:-${PGPID[birth_names]}}
		read -p "Birth date [${PGPID[birth_date]}] ? "
		PGPID[birth_date]=${REPLY:-${PGPID[birth_date]}}
		read -p "Birth country: [${PGPID[birth_country]}] ? "
		PGPID[birth_country]=${REPLY:-${PGPID[birth_country]}}
	done

	if PGPID[udid4]=$(pgpi_gen_udid4 --surname "${PGPID[birth_surname]}" --given-names "${PGPID[birth_names]}" --birth-date "${PGPID[birth_date]}" --birth-country "${PGPID[birth_country]}") ; then
		pl_log info "udid4:${PGPID[udid4]}"
	else
		pl_log error "can't generate an udid4 from data you have validated"
		continue
	fi

	outdir="${PGPI_OUTPATH%/}/${PGPID[udid4]}"
	mkdir -p "$outdir"
	cp -bvf "$f" "$outdir/document.orig" 2> >(pl_log warning) | pl_log info

	# Display scanned face
	pl_log notice "Displaying face... close it to continue !"
	(exec 2> >(pl_log error) ; basenc --base64url --decode <<<"${DOCUMENT[face_scan_64url]}" | tee "$outdir/face.jpg" | gm display -immutable - ) || continue

	_yesno "Did the image correspond to ${PGPID[birth_names],,} ${PGPID[birth_surname]}" || continue
	PGPID[face1_64url]="${DOCUMENT[face_scan_64url]}"


	while true ; do
		while true ; do
			read -p "Public email adress ? " PGPID[email]
			grep -q "^[^@[:space:]]\+@[^.[:space:]]\+\.[^[:space:]]\+$" <<<"${PGPID[email]}" && break
		done

		read -p "Public name (or pseudonym) ? " PGPID[pseudonym]
		echo -e "\nSummary:\n"\
				"Public name/pseudonym: ${PGPID[pseudonym]}\n"\
				"Public email: ${PGPID[email]}\n" >&2

		! _yesno "Is that correct" || break
	done

	pgpi_json_from_var --nested PGPID > "$outdir/pgpid.json" 2> >(pl_log crit)

	cat >"$outdir/gpg.genkey.batch" <<EOF
%echo Generating OpenPGP key for ${PGPID[pseudonym]}
Key-Type: default
Subkey-Type: ecdh
Subkey-Curve: Curve25519
Subkey-Usage: encrypt
Name-Real: ${PGPID[pseudonym]}
Name-Comment: udid4;${PGPID[udid4]}
Name-Email: ${PGPID[email]}
Expire-Date: $(date -I -d "+11 years")
Passphrase: ${PGPID[birth_date]//-/}
# Do a commit here, so that we can later print "done" :-)
%commit
EOF

	chmod 700 "$outdir"
	if ! gpg --homedir "$outdir" --batch --generate-key --allow-freeform-uid "$outdir/gpg.genkey.batch" 2> >(pl_log notice) ; then
		pl_log error "gpg --generate-key return $?"
		continue
	fi

	read PGPID[key_fpr_main] etc < <(gpg --homedir "$outdir" --list-options show-only-fpr-mbox --list-secret-keys 2> >(pl_log notice) )

	gpg --homedir "$outdir" --batch --passphrase "${PGPID[birth_date]//-/}" --pinentry-mode loopback --quick-add-key ${PGPID[key_fpr_main]} ed25519 auth 11y 2> >(pl_log notice)
	gpg --homedir "$outdir" --batch --passphrase "${PGPID[birth_date]//-/}" --pinentry-mode loopback --quick-add-key ${PGPID[key_fpr_main]} ed25519 sign 11y 2> >(pl_log notice)
	# Add photo
	gpg --homedir "$outdir" --command-fd 0 --passphrase "${PGPID[birth_date]//-/}" --pinentry-mode loopback --edit-key ${PGPID[key_fpr_main]} 2> >(pl_log notice) <<<"
addphoto
$outdir/face.jpg
y
save
"

done

exit 0
